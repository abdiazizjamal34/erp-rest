
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model customers
 * 
 */
export type customers = $Result.DefaultSelection<Prisma.$customersPayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model inventory
 * 
 */
export type inventory = $Result.DefaultSelection<Prisma.$inventoryPayload>
/**
 * Model orders
 * 
 */
export type orders = $Result.DefaultSelection<Prisma.$ordersPayload>
/**
 * Model order_items
 * 
 */
export type order_items = $Result.DefaultSelection<Prisma.$order_itemsPayload>
/**
 * Model payment_methods
 * 
 */
export type payment_methods = $Result.DefaultSelection<Prisma.$payment_methodsPayload>
/**
 * Model order_payments
 * 
 */
export type order_payments = $Result.DefaultSelection<Prisma.$order_paymentsPayload>
/**
 * Model returns
 * 
 */
export type returns = $Result.DefaultSelection<Prisma.$returnsPayload>
/**
 * Model return_items
 * 
 */
export type return_items = $Result.DefaultSelection<Prisma.$return_itemsPayload>
/**
 * Model inventory_transactions
 * 
 */
export type inventory_transactions = $Result.DefaultSelection<Prisma.$inventory_transactionsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.customersDelegate<ExtArgs>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.inventoryDelegate<ExtArgs>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.ordersDelegate<ExtArgs>;

  /**
   * `prisma.order_items`: Exposes CRUD operations for the **order_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_items
    * const order_items = await prisma.order_items.findMany()
    * ```
    */
  get order_items(): Prisma.order_itemsDelegate<ExtArgs>;

  /**
   * `prisma.payment_methods`: Exposes CRUD operations for the **payment_methods** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_methods
    * const payment_methods = await prisma.payment_methods.findMany()
    * ```
    */
  get payment_methods(): Prisma.payment_methodsDelegate<ExtArgs>;

  /**
   * `prisma.order_payments`: Exposes CRUD operations for the **order_payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_payments
    * const order_payments = await prisma.order_payments.findMany()
    * ```
    */
  get order_payments(): Prisma.order_paymentsDelegate<ExtArgs>;

  /**
   * `prisma.returns`: Exposes CRUD operations for the **returns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Returns
    * const returns = await prisma.returns.findMany()
    * ```
    */
  get returns(): Prisma.returnsDelegate<ExtArgs>;

  /**
   * `prisma.return_items`: Exposes CRUD operations for the **return_items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Return_items
    * const return_items = await prisma.return_items.findMany()
    * ```
    */
  get return_items(): Prisma.return_itemsDelegate<ExtArgs>;

  /**
   * `prisma.inventory_transactions`: Exposes CRUD operations for the **inventory_transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventory_transactions
    * const inventory_transactions = await prisma.inventory_transactions.findMany()
    * ```
    */
  get inventory_transactions(): Prisma.inventory_transactionsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    customers: 'customers',
    products: 'products',
    inventory: 'inventory',
    orders: 'orders',
    order_items: 'order_items',
    payment_methods: 'payment_methods',
    order_payments: 'order_payments',
    returns: 'returns',
    return_items: 'return_items',
    inventory_transactions: 'inventory_transactions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "users" | "customers" | "products" | "inventory" | "orders" | "order_items" | "payment_methods" | "order_payments" | "returns" | "return_items" | "inventory_transactions"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      customers: {
        payload: Prisma.$customersPayload<ExtArgs>
        fields: Prisma.customersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findFirst: {
            args: Prisma.customersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          findMany: {
            args: Prisma.customersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          create: {
            args: Prisma.customersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          createMany: {
            args: Prisma.customersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[]
          }
          delete: {
            args: Prisma.customersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          update: {
            args: Prisma.customersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          deleteMany: {
            args: Prisma.customersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.customersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.customersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      inventory: {
        payload: Prisma.$inventoryPayload<ExtArgs>
        fields: Prisma.inventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findFirst: {
            args: Prisma.inventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          findMany: {
            args: Prisma.inventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          create: {
            args: Prisma.inventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          createMany: {
            args: Prisma.inventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>[]
          }
          delete: {
            args: Prisma.inventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          update: {
            args: Prisma.inventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          deleteMany: {
            args: Prisma.inventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.inventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventoryCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      orders: {
        payload: Prisma.$ordersPayload<ExtArgs>
        fields: Prisma.ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findFirst: {
            args: Prisma.ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findMany: {
            args: Prisma.ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          create: {
            args: Prisma.ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          createMany: {
            args: Prisma.ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          delete: {
            args: Prisma.ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          update: {
            args: Prisma.ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          deleteMany: {
            args: Prisma.ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ordersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      order_items: {
        payload: Prisma.$order_itemsPayload<ExtArgs>
        fields: Prisma.order_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          findFirst: {
            args: Prisma.order_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          findMany: {
            args: Prisma.order_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>[]
          }
          create: {
            args: Prisma.order_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          createMany: {
            args: Prisma.order_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.order_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>[]
          }
          delete: {
            args: Prisma.order_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          update: {
            args: Prisma.order_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          deleteMany: {
            args: Prisma.order_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.order_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_itemsPayload>
          }
          aggregate: {
            args: Prisma.Order_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_items>
          }
          groupBy: {
            args: Prisma.order_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Order_itemsCountAggregateOutputType> | number
          }
        }
      }
      payment_methods: {
        payload: Prisma.$payment_methodsPayload<ExtArgs>
        fields: Prisma.payment_methodsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_methodsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_methodsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          findFirst: {
            args: Prisma.payment_methodsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_methodsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          findMany: {
            args: Prisma.payment_methodsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>[]
          }
          create: {
            args: Prisma.payment_methodsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          createMany: {
            args: Prisma.payment_methodsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payment_methodsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>[]
          }
          delete: {
            args: Prisma.payment_methodsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          update: {
            args: Prisma.payment_methodsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          deleteMany: {
            args: Prisma.payment_methodsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payment_methodsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.payment_methodsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payment_methodsPayload>
          }
          aggregate: {
            args: Prisma.Payment_methodsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment_methods>
          }
          groupBy: {
            args: Prisma.payment_methodsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodsGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_methodsCountArgs<ExtArgs>
            result: $Utils.Optional<Payment_methodsCountAggregateOutputType> | number
          }
        }
      }
      order_payments: {
        payload: Prisma.$order_paymentsPayload<ExtArgs>
        fields: Prisma.order_paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>
          }
          findFirst: {
            args: Prisma.order_paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>
          }
          findMany: {
            args: Prisma.order_paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>[]
          }
          create: {
            args: Prisma.order_paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>
          }
          createMany: {
            args: Prisma.order_paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.order_paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>[]
          }
          delete: {
            args: Prisma.order_paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>
          }
          update: {
            args: Prisma.order_paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>
          }
          deleteMany: {
            args: Prisma.order_paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.order_paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.order_paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$order_paymentsPayload>
          }
          aggregate: {
            args: Prisma.Order_paymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder_payments>
          }
          groupBy: {
            args: Prisma.order_paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Order_paymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<Order_paymentsCountAggregateOutputType> | number
          }
        }
      }
      returns: {
        payload: Prisma.$returnsPayload<ExtArgs>
        fields: Prisma.returnsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.returnsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.returnsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>
          }
          findFirst: {
            args: Prisma.returnsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.returnsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>
          }
          findMany: {
            args: Prisma.returnsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>[]
          }
          create: {
            args: Prisma.returnsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>
          }
          createMany: {
            args: Prisma.returnsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.returnsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>[]
          }
          delete: {
            args: Prisma.returnsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>
          }
          update: {
            args: Prisma.returnsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>
          }
          deleteMany: {
            args: Prisma.returnsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.returnsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.returnsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$returnsPayload>
          }
          aggregate: {
            args: Prisma.ReturnsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturns>
          }
          groupBy: {
            args: Prisma.returnsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnsGroupByOutputType>[]
          }
          count: {
            args: Prisma.returnsCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnsCountAggregateOutputType> | number
          }
        }
      }
      return_items: {
        payload: Prisma.$return_itemsPayload<ExtArgs>
        fields: Prisma.return_itemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.return_itemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.return_itemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>
          }
          findFirst: {
            args: Prisma.return_itemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.return_itemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>
          }
          findMany: {
            args: Prisma.return_itemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>[]
          }
          create: {
            args: Prisma.return_itemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>
          }
          createMany: {
            args: Prisma.return_itemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.return_itemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>[]
          }
          delete: {
            args: Prisma.return_itemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>
          }
          update: {
            args: Prisma.return_itemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>
          }
          deleteMany: {
            args: Prisma.return_itemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.return_itemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.return_itemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$return_itemsPayload>
          }
          aggregate: {
            args: Prisma.Return_itemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturn_items>
          }
          groupBy: {
            args: Prisma.return_itemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Return_itemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.return_itemsCountArgs<ExtArgs>
            result: $Utils.Optional<Return_itemsCountAggregateOutputType> | number
          }
        }
      }
      inventory_transactions: {
        payload: Prisma.$inventory_transactionsPayload<ExtArgs>
        fields: Prisma.inventory_transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inventory_transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inventory_transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>
          }
          findFirst: {
            args: Prisma.inventory_transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inventory_transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>
          }
          findMany: {
            args: Prisma.inventory_transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>[]
          }
          create: {
            args: Prisma.inventory_transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>
          }
          createMany: {
            args: Prisma.inventory_transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inventory_transactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>[]
          }
          delete: {
            args: Prisma.inventory_transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>
          }
          update: {
            args: Prisma.inventory_transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>
          }
          deleteMany: {
            args: Prisma.inventory_transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inventory_transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.inventory_transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inventory_transactionsPayload>
          }
          aggregate: {
            args: Prisma.Inventory_transactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventory_transactions>
          }
          groupBy: {
            args: Prisma.inventory_transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Inventory_transactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.inventory_transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Inventory_transactionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    orders: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomersCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    order_items: number
    inventory_transactions: number
    return_items: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | ProductsCountOutputTypeCountOrder_itemsArgs
    inventory_transactions?: boolean | ProductsCountOutputTypeCountInventory_transactionsArgs
    return_items?: boolean | ProductsCountOutputTypeCountReturn_itemsArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountInventory_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventory_transactionsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountReturn_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_itemsWhereInput
  }


  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    order_items: number
    order_payments: number
    inventory_transactions: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | OrdersCountOutputTypeCountOrder_itemsArgs
    order_payments?: boolean | OrdersCountOutputTypeCountOrder_paymentsArgs
    inventory_transactions?: boolean | OrdersCountOutputTypeCountInventory_transactionsArgs
  }

  // Custom InputTypes
  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemsWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrder_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_paymentsWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountInventory_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventory_transactionsWhereInput
  }


  /**
   * Count Type Payment_methodsCountOutputType
   */

  export type Payment_methodsCountOutputType = {
    order_payments: number
  }

  export type Payment_methodsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_payments?: boolean | Payment_methodsCountOutputTypeCountOrder_paymentsArgs
  }

  // Custom InputTypes
  /**
   * Payment_methodsCountOutputType without action
   */
  export type Payment_methodsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_methodsCountOutputType
     */
    select?: Payment_methodsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Payment_methodsCountOutputType without action
   */
  export type Payment_methodsCountOutputTypeCountOrder_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_paymentsWhereInput
  }


  /**
   * Count Type ReturnsCountOutputType
   */

  export type ReturnsCountOutputType = {
    return_items: number
    inventory_transactions: number
  }

  export type ReturnsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    return_items?: boolean | ReturnsCountOutputTypeCountReturn_itemsArgs
    inventory_transactions?: boolean | ReturnsCountOutputTypeCountInventory_transactionsArgs
  }

  // Custom InputTypes
  /**
   * ReturnsCountOutputType without action
   */
  export type ReturnsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsCountOutputType
     */
    select?: ReturnsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReturnsCountOutputType without action
   */
  export type ReturnsCountOutputTypeCountReturn_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_itemsWhereInput
  }

  /**
   * ReturnsCountOutputType without action
   */
  export type ReturnsCountOutputTypeCountInventory_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventory_transactionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    created_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: string | null
    created_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    email: number
    password: number
    name: number
    role: number
    created_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    created_at?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    created_at?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: string
    email: string
    password: string
    name: string | null
    role: string
    created_at: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    user_id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    created_at?: boolean
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      email: string
      password: string
      name: string | null
      role: string
      created_at: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
  }


  /**
   * Model customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersMinAggregateOutputType = {
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    created_at: Date | null
  }

  export type CustomersMaxAggregateOutputType = {
    customer_id: string | null
    name: string | null
    email: string | null
    phone: string | null
    created_at: Date | null
  }

  export type CustomersCountAggregateOutputType = {
    customer_id: number
    name: number
    email: number
    phone: number
    created_at: number
    _all: number
  }


  export type CustomersMinAggregateInputType = {
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    created_at?: true
  }

  export type CustomersMaxAggregateInputType = {
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    created_at?: true
  }

  export type CustomersCountAggregateInputType = {
    customer_id?: true
    name?: true
    email?: true
    phone?: true
    created_at?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to aggregate.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput
    orderBy?: customersOrderByWithAggregationInput | customersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: customersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    customer_id: string
    name: string
    email: string | null
    phone: string | null
    created_at: Date
    _count: CustomersCountAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends customersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    created_at?: boolean
    orders?: boolean | customers$ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type customersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customer_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["customers"]>

  export type customersSelectScalar = {
    customer_id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    created_at?: boolean
  }

  export type customersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | customers$ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customers"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      customer_id: string
      name: string
      email: string | null
      phone: string | null
      created_at: Date
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type customersGetPayload<S extends boolean | null | undefined | customersDefaultArgs> = $Result.GetResult<Prisma.$customersPayload, S>

  type customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<customersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface customersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customers'], meta: { name: 'customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {customersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customersFindUniqueArgs>(args: SelectSubset<T, customersFindUniqueArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {customersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customersFindUniqueOrThrowArgs>(args: SelectSubset<T, customersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customersFindFirstArgs>(args?: SelectSubset<T, customersFindFirstArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customersFindFirstOrThrowArgs>(args?: SelectSubset<T, customersFindFirstOrThrowArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `customer_id`
     * const customersWithCustomer_idOnly = await prisma.customers.findMany({ select: { customer_id: true } })
     * 
     */
    findMany<T extends customersFindManyArgs>(args?: SelectSubset<T, customersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customers.
     * @param {customersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends customersCreateArgs>(args: SelectSubset<T, customersCreateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {customersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customersCreateManyArgs>(args?: SelectSubset<T, customersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `customer_id`
     * const customersWithCustomer_idOnly = await prisma.customers.createManyAndReturn({ 
     *   select: { customer_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customersCreateManyAndReturnArgs>(args?: SelectSubset<T, customersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customers.
     * @param {customersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends customersDeleteArgs>(args: SelectSubset<T, customersDeleteArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customers.
     * @param {customersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customersUpdateArgs>(args: SelectSubset<T, customersUpdateArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customersDeleteManyArgs>(args?: SelectSubset<T, customersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customersUpdateManyArgs>(args: SelectSubset<T, customersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends customersUpsertArgs>(args: SelectSubset<T, customersUpsertArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customersCountArgs>(
      args?: Subset<T, customersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customersGroupByArgs['orderBy'] }
        : { orderBy?: customersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customers model
   */
  readonly fields: customersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends customers$ordersArgs<ExtArgs> = {}>(args?: Subset<T, customers$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customers model
   */ 
  interface customersFieldRefs {
    readonly customer_id: FieldRef<"customers", 'String'>
    readonly name: FieldRef<"customers", 'String'>
    readonly email: FieldRef<"customers", 'String'>
    readonly phone: FieldRef<"customers", 'String'>
    readonly created_at: FieldRef<"customers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customers findUnique
   */
  export type customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findUniqueOrThrow
   */
  export type customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers findFirst
   */
  export type customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findFirstOrThrow
   */
  export type customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers findMany
   */
  export type customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * customers create
   */
  export type customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to create a customers.
     */
    data: XOR<customersCreateInput, customersUncheckedCreateInput>
  }

  /**
   * customers createMany
   */
  export type customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers createManyAndReturn
   */
  export type customersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customers update
   */
  export type customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The data needed to update a customers.
     */
    data: XOR<customersUpdateInput, customersUncheckedUpdateInput>
    /**
     * Choose, which customers to update.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers updateMany
   */
  export type customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput
  }

  /**
   * customers upsert
   */
  export type customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * The filter to search for the customers to update in case it exists.
     */
    where: customersWhereUniqueInput
    /**
     * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
     */
    create: XOR<customersCreateInput, customersUncheckedCreateInput>
    /**
     * In case the customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customersUpdateInput, customersUncheckedUpdateInput>
  }

  /**
   * customers delete
   */
  export type customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    /**
     * Filter which customers to delete.
     */
    where: customersWhereUniqueInput
  }

  /**
   * customers deleteMany
   */
  export type customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customersWhereInput
  }

  /**
   * customers.orders
   */
  export type customers$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * customers without action
   */
  export type customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type ProductsSumAggregateOutputType = {
    price: Decimal | null
  }

  export type ProductsMinAggregateOutputType = {
    product_id: string | null
    name: string | null
    sku: string | null
    barcode: string | null
    description: string | null
    price: Decimal | null
    created_at: Date | null
  }

  export type ProductsMaxAggregateOutputType = {
    product_id: string | null
    name: string | null
    sku: string | null
    barcode: string | null
    description: string | null
    price: Decimal | null
    created_at: Date | null
  }

  export type ProductsCountAggregateOutputType = {
    product_id: number
    name: number
    sku: number
    barcode: number
    description: number
    price: number
    created_at: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    price?: true
  }

  export type ProductsSumAggregateInputType = {
    price?: true
  }

  export type ProductsMinAggregateInputType = {
    product_id?: true
    name?: true
    sku?: true
    barcode?: true
    description?: true
    price?: true
    created_at?: true
  }

  export type ProductsMaxAggregateInputType = {
    product_id?: true
    name?: true
    sku?: true
    barcode?: true
    description?: true
    price?: true
    created_at?: true
  }

  export type ProductsCountAggregateInputType = {
    product_id?: true
    name?: true
    sku?: true
    barcode?: true
    description?: true
    price?: true
    created_at?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    product_id: string
    name: string
    sku: string
    barcode: string | null
    description: string | null
    price: Decimal
    created_at: Date
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    name?: boolean
    sku?: boolean
    barcode?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
    inventory?: boolean | products$inventoryArgs<ExtArgs>
    order_items?: boolean | products$order_itemsArgs<ExtArgs>
    inventory_transactions?: boolean | products$inventory_transactionsArgs<ExtArgs>
    return_items?: boolean | products$return_itemsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    name?: boolean
    sku?: boolean
    barcode?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["products"]>

  export type productsSelectScalar = {
    product_id?: boolean
    name?: boolean
    sku?: boolean
    barcode?: boolean
    description?: boolean
    price?: boolean
    created_at?: boolean
  }

  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | products$inventoryArgs<ExtArgs>
    order_items?: boolean | products$order_itemsArgs<ExtArgs>
    inventory_transactions?: boolean | products$inventory_transactionsArgs<ExtArgs>
    return_items?: boolean | products$return_itemsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {
      inventory: Prisma.$inventoryPayload<ExtArgs> | null
      order_items: Prisma.$order_itemsPayload<ExtArgs>[]
      inventory_transactions: Prisma.$inventory_transactionsPayload<ExtArgs>[]
      return_items: Prisma.$return_itemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      product_id: string
      name: string
      sku: string
      barcode: string | null
      description: string | null
      price: Prisma.Decimal
      created_at: Date
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `product_id`
     * const productsWithProduct_idOnly = await prisma.products.findMany({ select: { product_id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `product_id`
     * const productsWithProduct_idOnly = await prisma.products.createManyAndReturn({ 
     *   select: { product_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productsCreateManyAndReturnArgs>(args?: SelectSubset<T, productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inventory<T extends products$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, products$inventoryArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order_items<T extends products$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, products$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findMany"> | Null>
    inventory_transactions<T extends products$inventory_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, products$inventory_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findMany"> | Null>
    return_items<T extends products$return_itemsArgs<ExtArgs> = {}>(args?: Subset<T, products$return_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */ 
  interface productsFieldRefs {
    readonly product_id: FieldRef<"products", 'String'>
    readonly name: FieldRef<"products", 'String'>
    readonly sku: FieldRef<"products", 'String'>
    readonly barcode: FieldRef<"products", 'String'>
    readonly description: FieldRef<"products", 'String'>
    readonly price: FieldRef<"products", 'Decimal'>
    readonly created_at: FieldRef<"products", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products createManyAndReturn
   */
  export type productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
  }

  /**
   * products.inventory
   */
  export type products$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    where?: inventoryWhereInput
  }

  /**
   * products.order_items
   */
  export type products$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    where?: order_itemsWhereInput
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    cursor?: order_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * products.inventory_transactions
   */
  export type products$inventory_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    where?: inventory_transactionsWhereInput
    orderBy?: inventory_transactionsOrderByWithRelationInput | inventory_transactionsOrderByWithRelationInput[]
    cursor?: inventory_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inventory_transactionsScalarFieldEnum | Inventory_transactionsScalarFieldEnum[]
  }

  /**
   * products.return_items
   */
  export type products$return_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    where?: return_itemsWhereInput
    orderBy?: return_itemsOrderByWithRelationInput | return_itemsOrderByWithRelationInput[]
    cursor?: return_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Return_itemsScalarFieldEnum | Return_itemsScalarFieldEnum[]
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
  }


  /**
   * Model inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventorySumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryMinAggregateOutputType = {
    inventory_id: string | null
    product_id: string | null
    quantity: number | null
    updated_at: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    inventory_id: string | null
    product_id: string | null
    quantity: number | null
    updated_at: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    inventory_id: number
    product_id: number
    quantity: number
    updated_at: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    quantity?: true
  }

  export type InventorySumAggregateInputType = {
    quantity?: true
  }

  export type InventoryMinAggregateInputType = {
    inventory_id?: true
    product_id?: true
    quantity?: true
    updated_at?: true
  }

  export type InventoryMaxAggregateInputType = {
    inventory_id?: true
    product_id?: true
    quantity?: true
    updated_at?: true
  }

  export type InventoryCountAggregateInputType = {
    inventory_id?: true
    product_id?: true
    quantity?: true
    updated_at?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory to aggregate.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type inventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventoryWhereInput
    orderBy?: inventoryOrderByWithAggregationInput | inventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: inventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    inventory_id: string
    product_id: string
    quantity: number
    updated_at: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends inventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type inventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inventory_id?: boolean
    product_id?: boolean
    quantity?: boolean
    updated_at?: boolean
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inventory_id?: boolean
    product_id?: boolean
    quantity?: boolean
    updated_at?: boolean
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type inventorySelectScalar = {
    inventory_id?: boolean
    product_id?: boolean
    quantity?: boolean
    updated_at?: boolean
  }

  export type inventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productsDefaultArgs<ExtArgs>
  }
  export type inventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productsDefaultArgs<ExtArgs>
  }

  export type $inventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventory"
    objects: {
      product: Prisma.$productsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      inventory_id: string
      product_id: string
      quantity: number
      updated_at: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }

  type inventoryGetPayload<S extends boolean | null | undefined | inventoryDefaultArgs> = $Result.GetResult<Prisma.$inventoryPayload, S>

  type inventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<inventoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface inventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventory'], meta: { name: 'inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {inventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventoryFindUniqueArgs>(args: SelectSubset<T, inventoryFindUniqueArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {inventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, inventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventoryFindFirstArgs>(args?: SelectSubset<T, inventoryFindFirstArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, inventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `inventory_id`
     * const inventoryWithInventory_idOnly = await prisma.inventory.findMany({ select: { inventory_id: true } })
     * 
     */
    findMany<T extends inventoryFindManyArgs>(args?: SelectSubset<T, inventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventory.
     * @param {inventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
     */
    create<T extends inventoryCreateArgs>(args: SelectSubset<T, inventoryCreateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventories.
     * @param {inventoryCreateManyArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventoryCreateManyArgs>(args?: SelectSubset<T, inventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventories and returns the data saved in the database.
     * @param {inventoryCreateManyAndReturnArgs} args - Arguments to create many Inventories.
     * @example
     * // Create many Inventories
     * const inventory = await prisma.inventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventories and only return the `inventory_id`
     * const inventoryWithInventory_idOnly = await prisma.inventory.createManyAndReturn({ 
     *   select: { inventory_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, inventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inventory.
     * @param {inventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
     */
    delete<T extends inventoryDeleteArgs>(args: SelectSubset<T, inventoryDeleteArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventory.
     * @param {inventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventoryUpdateArgs>(args: SelectSubset<T, inventoryUpdateArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {inventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventoryDeleteManyArgs>(args?: SelectSubset<T, inventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventoryUpdateManyArgs>(args: SelectSubset<T, inventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {inventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
     */
    upsert<T extends inventoryUpsertArgs>(args: SelectSubset<T, inventoryUpsertArgs<ExtArgs>>): Prisma__inventoryClient<$Result.GetResult<Prisma.$inventoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends inventoryCountArgs>(
      args?: Subset<T, inventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventoryGroupByArgs['orderBy'] }
        : { orderBy?: inventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventory model
   */
  readonly fields: inventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsDefaultArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventory model
   */ 
  interface inventoryFieldRefs {
    readonly inventory_id: FieldRef<"inventory", 'String'>
    readonly product_id: FieldRef<"inventory", 'String'>
    readonly quantity: FieldRef<"inventory", 'Int'>
    readonly updated_at: FieldRef<"inventory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inventory findUnique
   */
  export type inventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findUniqueOrThrow
   */
  export type inventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory findFirst
   */
  export type inventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findFirstOrThrow
   */
  export type inventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventory to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory findMany
   */
  export type inventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter, which inventories to fetch.
     */
    where?: inventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventories to fetch.
     */
    orderBy?: inventoryOrderByWithRelationInput | inventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventories.
     */
    cursor?: inventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }

  /**
   * inventory create
   */
  export type inventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a inventory.
     */
    data: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
  }

  /**
   * inventory createMany
   */
  export type inventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventories.
     */
    data: inventoryCreateManyInput | inventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventory createManyAndReturn
   */
  export type inventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many inventories.
     */
    data: inventoryCreateManyInput | inventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inventory update
   */
  export type inventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a inventory.
     */
    data: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
    /**
     * Choose, which inventory to update.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory updateMany
   */
  export type inventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventories.
     */
    data: XOR<inventoryUpdateManyMutationInput, inventoryUncheckedUpdateManyInput>
    /**
     * Filter which inventories to update
     */
    where?: inventoryWhereInput
  }

  /**
   * inventory upsert
   */
  export type inventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the inventory to update in case it exists.
     */
    where: inventoryWhereUniqueInput
    /**
     * In case the inventory found by the `where` argument doesn't exist, create a new inventory with this data.
     */
    create: XOR<inventoryCreateInput, inventoryUncheckedCreateInput>
    /**
     * In case the inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventoryUpdateInput, inventoryUncheckedUpdateInput>
  }

  /**
   * inventory delete
   */
  export type inventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
    /**
     * Filter which inventory to delete.
     */
    where: inventoryWhereUniqueInput
  }

  /**
   * inventory deleteMany
   */
  export type inventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventories to delete
     */
    where?: inventoryWhereInput
  }

  /**
   * inventory without action
   */
  export type inventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory
     */
    select?: inventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventoryInclude<ExtArgs> | null
  }


  /**
   * Model orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    order_id: number | null
    total_amount: Decimal | null
  }

  export type OrdersSumAggregateOutputType = {
    order_id: number | null
    total_amount: Decimal | null
  }

  export type OrdersMinAggregateOutputType = {
    order_id: number | null
    customer_id: string | null
    order_date: Date | null
    status: string | null
    total_amount: Decimal | null
  }

  export type OrdersMaxAggregateOutputType = {
    order_id: number | null
    customer_id: string | null
    order_date: Date | null
    status: string | null
    total_amount: Decimal | null
  }

  export type OrdersCountAggregateOutputType = {
    order_id: number
    customer_id: number
    order_date: number
    status: number
    total_amount: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    order_id?: true
    total_amount?: true
  }

  export type OrdersSumAggregateInputType = {
    order_id?: true
    total_amount?: true
  }

  export type OrdersMinAggregateInputType = {
    order_id?: true
    customer_id?: true
    order_date?: true
    status?: true
    total_amount?: true
  }

  export type OrdersMaxAggregateInputType = {
    order_id?: true
    customer_id?: true
    order_date?: true
    status?: true
    total_amount?: true
  }

  export type OrdersCountAggregateInputType = {
    order_id?: true
    customer_id?: true
    order_date?: true
    status?: true
    total_amount?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to aggregate.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithAggregationInput | ordersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    order_id: number
    customer_id: string | null
    order_date: Date
    status: string
    total_amount: Decimal
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    customer_id?: boolean
    order_date?: boolean
    status?: boolean
    total_amount?: boolean
    customer?: boolean | orders$customerArgs<ExtArgs>
    order_items?: boolean | orders$order_itemsArgs<ExtArgs>
    order_payments?: boolean | orders$order_paymentsArgs<ExtArgs>
    returns?: boolean | orders$returnsArgs<ExtArgs>
    inventory_transactions?: boolean | orders$inventory_transactionsArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    customer_id?: boolean
    order_date?: boolean
    status?: boolean
    total_amount?: boolean
    customer?: boolean | orders$customerArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectScalar = {
    order_id?: boolean
    customer_id?: boolean
    order_date?: boolean
    status?: boolean
    total_amount?: boolean
  }

  export type ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | orders$customerArgs<ExtArgs>
    order_items?: boolean | orders$order_itemsArgs<ExtArgs>
    order_payments?: boolean | orders$order_paymentsArgs<ExtArgs>
    returns?: boolean | orders$returnsArgs<ExtArgs>
    inventory_transactions?: boolean | orders$inventory_transactionsArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | orders$customerArgs<ExtArgs>
  }

  export type $ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orders"
    objects: {
      customer: Prisma.$customersPayload<ExtArgs> | null
      order_items: Prisma.$order_itemsPayload<ExtArgs>[]
      order_payments: Prisma.$order_paymentsPayload<ExtArgs>[]
      returns: Prisma.$returnsPayload<ExtArgs> | null
      inventory_transactions: Prisma.$inventory_transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      order_id: number
      customer_id: string | null
      order_date: Date
      status: string
      total_amount: Prisma.Decimal
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type ordersGetPayload<S extends boolean | null | undefined | ordersDefaultArgs> = $Result.GetResult<Prisma.$ordersPayload, S>

  type ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ordersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orders'], meta: { name: 'orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {ordersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ordersFindUniqueArgs>(args: SelectSubset<T, ordersFindUniqueArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ordersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ordersFindFirstArgs>(args?: SelectSubset<T, ordersFindFirstArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const ordersWithOrder_idOnly = await prisma.orders.findMany({ select: { order_id: true } })
     * 
     */
    findMany<T extends ordersFindManyArgs>(args?: SelectSubset<T, ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Orders.
     * @param {ordersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends ordersCreateArgs>(args: SelectSubset<T, ordersCreateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {ordersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ordersCreateManyArgs>(args?: SelectSubset<T, ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {ordersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `order_id`
     * const ordersWithOrder_idOnly = await prisma.orders.createManyAndReturn({ 
     *   select: { order_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Orders.
     * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends ordersDeleteArgs>(args: SelectSubset<T, ordersDeleteArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Orders.
     * @param {ordersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ordersUpdateArgs>(args: SelectSubset<T, ordersUpdateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ordersDeleteManyArgs>(args?: SelectSubset<T, ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ordersUpdateManyArgs>(args: SelectSubset<T, ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends ordersUpsertArgs>(args: SelectSubset<T, ordersUpsertArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends ordersCountArgs>(
      args?: Subset<T, ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordersGroupByArgs['orderBy'] }
        : { orderBy?: ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orders model
   */
  readonly fields: ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends orders$customerArgs<ExtArgs> = {}>(args?: Subset<T, orders$customerArgs<ExtArgs>>): Prisma__customersClient<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order_items<T extends orders$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, orders$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findMany"> | Null>
    order_payments<T extends orders$order_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, orders$order_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "findMany"> | Null>
    returns<T extends orders$returnsArgs<ExtArgs> = {}>(args?: Subset<T, orders$returnsArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    inventory_transactions<T extends orders$inventory_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, orders$inventory_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the orders model
   */ 
  interface ordersFieldRefs {
    readonly order_id: FieldRef<"orders", 'Int'>
    readonly customer_id: FieldRef<"orders", 'String'>
    readonly order_date: FieldRef<"orders", 'DateTime'>
    readonly status: FieldRef<"orders", 'String'>
    readonly total_amount: FieldRef<"orders", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * orders findUnique
   */
  export type ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findUniqueOrThrow
   */
  export type ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findFirst
   */
  export type ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findFirstOrThrow
   */
  export type ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findMany
   */
  export type ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders create
   */
  export type ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to create a orders.
     */
    data?: XOR<ordersCreateInput, ordersUncheckedCreateInput>
  }

  /**
   * orders createMany
   */
  export type ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orders createManyAndReturn
   */
  export type ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * orders update
   */
  export type ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to update a orders.
     */
    data: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
    /**
     * Choose, which orders to update.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders updateMany
   */
  export type ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
  }

  /**
   * orders upsert
   */
  export type ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The filter to search for the orders to update in case it exists.
     */
    where: ordersWhereUniqueInput
    /**
     * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
     */
    create: XOR<ordersCreateInput, ordersUncheckedCreateInput>
    /**
     * In case the orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
  }

  /**
   * orders delete
   */
  export type ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter which orders to delete.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders deleteMany
   */
  export type ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: ordersWhereInput
  }

  /**
   * orders.customer
   */
  export type orders$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null
    where?: customersWhereInput
  }

  /**
   * orders.order_items
   */
  export type orders$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    where?: order_itemsWhereInput
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    cursor?: order_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * orders.order_payments
   */
  export type orders$order_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    where?: order_paymentsWhereInput
    orderBy?: order_paymentsOrderByWithRelationInput | order_paymentsOrderByWithRelationInput[]
    cursor?: order_paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_paymentsScalarFieldEnum | Order_paymentsScalarFieldEnum[]
  }

  /**
   * orders.returns
   */
  export type orders$returnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    where?: returnsWhereInput
  }

  /**
   * orders.inventory_transactions
   */
  export type orders$inventory_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    where?: inventory_transactionsWhereInput
    orderBy?: inventory_transactionsOrderByWithRelationInput | inventory_transactionsOrderByWithRelationInput[]
    cursor?: inventory_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inventory_transactionsScalarFieldEnum | Inventory_transactionsScalarFieldEnum[]
  }

  /**
   * orders without action
   */
  export type ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
  }


  /**
   * Model order_items
   */

  export type AggregateOrder_items = {
    _count: Order_itemsCountAggregateOutputType | null
    _avg: Order_itemsAvgAggregateOutputType | null
    _sum: Order_itemsSumAggregateOutputType | null
    _min: Order_itemsMinAggregateOutputType | null
    _max: Order_itemsMaxAggregateOutputType | null
  }

  export type Order_itemsAvgAggregateOutputType = {
    order_id: number | null
    quantity: number | null
    unit_price: Decimal | null
    subtotal: Decimal | null
  }

  export type Order_itemsSumAggregateOutputType = {
    order_id: number | null
    quantity: number | null
    unit_price: Decimal | null
    subtotal: Decimal | null
  }

  export type Order_itemsMinAggregateOutputType = {
    order_item_id: string | null
    order_id: number | null
    product_id: string | null
    quantity: number | null
    unit_price: Decimal | null
    subtotal: Decimal | null
  }

  export type Order_itemsMaxAggregateOutputType = {
    order_item_id: string | null
    order_id: number | null
    product_id: string | null
    quantity: number | null
    unit_price: Decimal | null
    subtotal: Decimal | null
  }

  export type Order_itemsCountAggregateOutputType = {
    order_item_id: number
    order_id: number
    product_id: number
    quantity: number
    unit_price: number
    subtotal: number
    _all: number
  }


  export type Order_itemsAvgAggregateInputType = {
    order_id?: true
    quantity?: true
    unit_price?: true
    subtotal?: true
  }

  export type Order_itemsSumAggregateInputType = {
    order_id?: true
    quantity?: true
    unit_price?: true
    subtotal?: true
  }

  export type Order_itemsMinAggregateInputType = {
    order_item_id?: true
    order_id?: true
    product_id?: true
    quantity?: true
    unit_price?: true
    subtotal?: true
  }

  export type Order_itemsMaxAggregateInputType = {
    order_item_id?: true
    order_id?: true
    product_id?: true
    quantity?: true
    unit_price?: true
    subtotal?: true
  }

  export type Order_itemsCountAggregateInputType = {
    order_item_id?: true
    order_id?: true
    product_id?: true
    quantity?: true
    unit_price?: true
    subtotal?: true
    _all?: true
  }

  export type Order_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_items to aggregate.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_items
    **/
    _count?: true | Order_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_itemsMaxAggregateInputType
  }

  export type GetOrder_itemsAggregateType<T extends Order_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_items[P]>
      : GetScalarType<T[P], AggregateOrder_items[P]>
  }




  export type order_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_itemsWhereInput
    orderBy?: order_itemsOrderByWithAggregationInput | order_itemsOrderByWithAggregationInput[]
    by: Order_itemsScalarFieldEnum[] | Order_itemsScalarFieldEnum
    having?: order_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_itemsCountAggregateInputType | true
    _avg?: Order_itemsAvgAggregateInputType
    _sum?: Order_itemsSumAggregateInputType
    _min?: Order_itemsMinAggregateInputType
    _max?: Order_itemsMaxAggregateInputType
  }

  export type Order_itemsGroupByOutputType = {
    order_item_id: string
    order_id: number
    product_id: string
    quantity: number
    unit_price: Decimal
    subtotal: Decimal
    _count: Order_itemsCountAggregateOutputType | null
    _avg: Order_itemsAvgAggregateOutputType | null
    _sum: Order_itemsSumAggregateOutputType | null
    _min: Order_itemsMinAggregateOutputType | null
    _max: Order_itemsMaxAggregateOutputType | null
  }

  type GetOrder_itemsGroupByPayload<T extends order_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Order_itemsGroupByOutputType[P]>
        }
      >
    >


  export type order_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_item_id?: boolean
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    subtotal?: boolean
    order?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_items"]>

  export type order_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_item_id?: boolean
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    subtotal?: boolean
    order?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_items"]>

  export type order_itemsSelectScalar = {
    order_item_id?: boolean
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    unit_price?: boolean
    subtotal?: boolean
  }

  export type order_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }
  export type order_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }

  export type $order_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_items"
    objects: {
      order: Prisma.$ordersPayload<ExtArgs>
      product: Prisma.$productsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      order_item_id: string
      order_id: number
      product_id: string
      quantity: number
      unit_price: Prisma.Decimal
      subtotal: Prisma.Decimal
    }, ExtArgs["result"]["order_items"]>
    composites: {}
  }

  type order_itemsGetPayload<S extends boolean | null | undefined | order_itemsDefaultArgs> = $Result.GetResult<Prisma.$order_itemsPayload, S>

  type order_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Order_itemsCountAggregateInputType | true
    }

  export interface order_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_items'], meta: { name: 'order_items' } }
    /**
     * Find zero or one Order_items that matches the filter.
     * @param {order_itemsFindUniqueArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_itemsFindUniqueArgs>(args: SelectSubset<T, order_itemsFindUniqueArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {order_itemsFindUniqueOrThrowArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, order_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsFindFirstArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_itemsFindFirstArgs>(args?: SelectSubset<T, order_itemsFindFirstArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsFindFirstOrThrowArgs} args - Arguments to find a Order_items
     * @example
     * // Get one Order_items
     * const order_items = await prisma.order_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, order_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Order_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_items
     * const order_items = await prisma.order_items.findMany()
     * 
     * // Get first 10 Order_items
     * const order_items = await prisma.order_items.findMany({ take: 10 })
     * 
     * // Only select the `order_item_id`
     * const order_itemsWithOrder_item_idOnly = await prisma.order_items.findMany({ select: { order_item_id: true } })
     * 
     */
    findMany<T extends order_itemsFindManyArgs>(args?: SelectSubset<T, order_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order_items.
     * @param {order_itemsCreateArgs} args - Arguments to create a Order_items.
     * @example
     * // Create one Order_items
     * const Order_items = await prisma.order_items.create({
     *   data: {
     *     // ... data to create a Order_items
     *   }
     * })
     * 
     */
    create<T extends order_itemsCreateArgs>(args: SelectSubset<T, order_itemsCreateArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Order_items.
     * @param {order_itemsCreateManyArgs} args - Arguments to create many Order_items.
     * @example
     * // Create many Order_items
     * const order_items = await prisma.order_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_itemsCreateManyArgs>(args?: SelectSubset<T, order_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Order_items and returns the data saved in the database.
     * @param {order_itemsCreateManyAndReturnArgs} args - Arguments to create many Order_items.
     * @example
     * // Create many Order_items
     * const order_items = await prisma.order_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Order_items and only return the `order_item_id`
     * const order_itemsWithOrder_item_idOnly = await prisma.order_items.createManyAndReturn({ 
     *   select: { order_item_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends order_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, order_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order_items.
     * @param {order_itemsDeleteArgs} args - Arguments to delete one Order_items.
     * @example
     * // Delete one Order_items
     * const Order_items = await prisma.order_items.delete({
     *   where: {
     *     // ... filter to delete one Order_items
     *   }
     * })
     * 
     */
    delete<T extends order_itemsDeleteArgs>(args: SelectSubset<T, order_itemsDeleteArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order_items.
     * @param {order_itemsUpdateArgs} args - Arguments to update one Order_items.
     * @example
     * // Update one Order_items
     * const order_items = await prisma.order_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_itemsUpdateArgs>(args: SelectSubset<T, order_itemsUpdateArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Order_items.
     * @param {order_itemsDeleteManyArgs} args - Arguments to filter Order_items to delete.
     * @example
     * // Delete a few Order_items
     * const { count } = await prisma.order_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_itemsDeleteManyArgs>(args?: SelectSubset<T, order_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_items
     * const order_items = await prisma.order_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_itemsUpdateManyArgs>(args: SelectSubset<T, order_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_items.
     * @param {order_itemsUpsertArgs} args - Arguments to update or create a Order_items.
     * @example
     * // Update or create a Order_items
     * const order_items = await prisma.order_items.upsert({
     *   create: {
     *     // ... data to create a Order_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_items we want to update
     *   }
     * })
     */
    upsert<T extends order_itemsUpsertArgs>(args: SelectSubset<T, order_itemsUpsertArgs<ExtArgs>>): Prisma__order_itemsClient<$Result.GetResult<Prisma.$order_itemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsCountArgs} args - Arguments to filter Order_items to count.
     * @example
     * // Count the number of Order_items
     * const count = await prisma.order_items.count({
     *   where: {
     *     // ... the filter for the Order_items we want to count
     *   }
     * })
    **/
    count<T extends order_itemsCountArgs>(
      args?: Subset<T, order_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_itemsAggregateArgs>(args: Subset<T, Order_itemsAggregateArgs>): Prisma.PrismaPromise<GetOrder_itemsAggregateType<T>>

    /**
     * Group by Order_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_itemsGroupByArgs['orderBy'] }
        : { orderBy?: order_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_items model
   */
  readonly fields: order_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordersDefaultArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsDefaultArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_items model
   */ 
  interface order_itemsFieldRefs {
    readonly order_item_id: FieldRef<"order_items", 'String'>
    readonly order_id: FieldRef<"order_items", 'Int'>
    readonly product_id: FieldRef<"order_items", 'String'>
    readonly quantity: FieldRef<"order_items", 'Int'>
    readonly unit_price: FieldRef<"order_items", 'Decimal'>
    readonly subtotal: FieldRef<"order_items", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * order_items findUnique
   */
  export type order_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items findUniqueOrThrow
   */
  export type order_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items findFirst
   */
  export type order_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_items.
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_items.
     */
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * order_items findFirstOrThrow
   */
  export type order_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_items.
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_items.
     */
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * order_items findMany
   */
  export type order_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter, which order_items to fetch.
     */
    where?: order_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_items to fetch.
     */
    orderBy?: order_itemsOrderByWithRelationInput | order_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_items.
     */
    cursor?: order_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_items.
     */
    skip?: number
    distinct?: Order_itemsScalarFieldEnum | Order_itemsScalarFieldEnum[]
  }

  /**
   * order_items create
   */
  export type order_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a order_items.
     */
    data: XOR<order_itemsCreateInput, order_itemsUncheckedCreateInput>
  }

  /**
   * order_items createMany
   */
  export type order_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_items.
     */
    data: order_itemsCreateManyInput | order_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_items createManyAndReturn
   */
  export type order_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many order_items.
     */
    data: order_itemsCreateManyInput | order_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_items update
   */
  export type order_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a order_items.
     */
    data: XOR<order_itemsUpdateInput, order_itemsUncheckedUpdateInput>
    /**
     * Choose, which order_items to update.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items updateMany
   */
  export type order_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_items.
     */
    data: XOR<order_itemsUpdateManyMutationInput, order_itemsUncheckedUpdateManyInput>
    /**
     * Filter which order_items to update
     */
    where?: order_itemsWhereInput
  }

  /**
   * order_items upsert
   */
  export type order_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the order_items to update in case it exists.
     */
    where: order_itemsWhereUniqueInput
    /**
     * In case the order_items found by the `where` argument doesn't exist, create a new order_items with this data.
     */
    create: XOR<order_itemsCreateInput, order_itemsUncheckedCreateInput>
    /**
     * In case the order_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_itemsUpdateInput, order_itemsUncheckedUpdateInput>
  }

  /**
   * order_items delete
   */
  export type order_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
    /**
     * Filter which order_items to delete.
     */
    where: order_itemsWhereUniqueInput
  }

  /**
   * order_items deleteMany
   */
  export type order_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_items to delete
     */
    where?: order_itemsWhereInput
  }

  /**
   * order_items without action
   */
  export type order_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_items
     */
    select?: order_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_itemsInclude<ExtArgs> | null
  }


  /**
   * Model payment_methods
   */

  export type AggregatePayment_methods = {
    _count: Payment_methodsCountAggregateOutputType | null
    _min: Payment_methodsMinAggregateOutputType | null
    _max: Payment_methodsMaxAggregateOutputType | null
  }

  export type Payment_methodsMinAggregateOutputType = {
    payment_method_id: string | null
    method_name: string | null
    description: string | null
    created_at: Date | null
  }

  export type Payment_methodsMaxAggregateOutputType = {
    payment_method_id: string | null
    method_name: string | null
    description: string | null
    created_at: Date | null
  }

  export type Payment_methodsCountAggregateOutputType = {
    payment_method_id: number
    method_name: number
    description: number
    created_at: number
    _all: number
  }


  export type Payment_methodsMinAggregateInputType = {
    payment_method_id?: true
    method_name?: true
    description?: true
    created_at?: true
  }

  export type Payment_methodsMaxAggregateInputType = {
    payment_method_id?: true
    method_name?: true
    description?: true
    created_at?: true
  }

  export type Payment_methodsCountAggregateInputType = {
    payment_method_id?: true
    method_name?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type Payment_methodsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_methods to aggregate.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_methods
    **/
    _count?: true | Payment_methodsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_methodsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_methodsMaxAggregateInputType
  }

  export type GetPayment_methodsAggregateType<T extends Payment_methodsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_methods]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_methods[P]>
      : GetScalarType<T[P], AggregatePayment_methods[P]>
  }




  export type payment_methodsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_methodsWhereInput
    orderBy?: payment_methodsOrderByWithAggregationInput | payment_methodsOrderByWithAggregationInput[]
    by: Payment_methodsScalarFieldEnum[] | Payment_methodsScalarFieldEnum
    having?: payment_methodsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_methodsCountAggregateInputType | true
    _min?: Payment_methodsMinAggregateInputType
    _max?: Payment_methodsMaxAggregateInputType
  }

  export type Payment_methodsGroupByOutputType = {
    payment_method_id: string
    method_name: string
    description: string | null
    created_at: Date
    _count: Payment_methodsCountAggregateOutputType | null
    _min: Payment_methodsMinAggregateOutputType | null
    _max: Payment_methodsMaxAggregateOutputType | null
  }

  type GetPayment_methodsGroupByPayload<T extends payment_methodsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_methodsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_methodsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_methodsGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_methodsGroupByOutputType[P]>
        }
      >
    >


  export type payment_methodsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    method_name?: boolean
    description?: boolean
    created_at?: boolean
    order_payments?: boolean | payment_methods$order_paymentsArgs<ExtArgs>
    _count?: boolean | Payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_methods"]>

  export type payment_methodsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_method_id?: boolean
    method_name?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["payment_methods"]>

  export type payment_methodsSelectScalar = {
    payment_method_id?: boolean
    method_name?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type payment_methodsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_payments?: boolean | payment_methods$order_paymentsArgs<ExtArgs>
    _count?: boolean | Payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payment_methodsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $payment_methodsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_methods"
    objects: {
      order_payments: Prisma.$order_paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_method_id: string
      method_name: string
      description: string | null
      created_at: Date
    }, ExtArgs["result"]["payment_methods"]>
    composites: {}
  }

  type payment_methodsGetPayload<S extends boolean | null | undefined | payment_methodsDefaultArgs> = $Result.GetResult<Prisma.$payment_methodsPayload, S>

  type payment_methodsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<payment_methodsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Payment_methodsCountAggregateInputType | true
    }

  export interface payment_methodsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_methods'], meta: { name: 'payment_methods' } }
    /**
     * Find zero or one Payment_methods that matches the filter.
     * @param {payment_methodsFindUniqueArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_methodsFindUniqueArgs>(args: SelectSubset<T, payment_methodsFindUniqueArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment_methods that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {payment_methodsFindUniqueOrThrowArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_methodsFindUniqueOrThrowArgs>(args: SelectSubset<T, payment_methodsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsFindFirstArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_methodsFindFirstArgs>(args?: SelectSubset<T, payment_methodsFindFirstArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment_methods that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsFindFirstOrThrowArgs} args - Arguments to find a Payment_methods
     * @example
     * // Get one Payment_methods
     * const payment_methods = await prisma.payment_methods.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_methodsFindFirstOrThrowArgs>(args?: SelectSubset<T, payment_methodsFindFirstOrThrowArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_methods
     * const payment_methods = await prisma.payment_methods.findMany()
     * 
     * // Get first 10 Payment_methods
     * const payment_methods = await prisma.payment_methods.findMany({ take: 10 })
     * 
     * // Only select the `payment_method_id`
     * const payment_methodsWithPayment_method_idOnly = await prisma.payment_methods.findMany({ select: { payment_method_id: true } })
     * 
     */
    findMany<T extends payment_methodsFindManyArgs>(args?: SelectSubset<T, payment_methodsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment_methods.
     * @param {payment_methodsCreateArgs} args - Arguments to create a Payment_methods.
     * @example
     * // Create one Payment_methods
     * const Payment_methods = await prisma.payment_methods.create({
     *   data: {
     *     // ... data to create a Payment_methods
     *   }
     * })
     * 
     */
    create<T extends payment_methodsCreateArgs>(args: SelectSubset<T, payment_methodsCreateArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payment_methods.
     * @param {payment_methodsCreateManyArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_methods = await prisma.payment_methods.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payment_methodsCreateManyArgs>(args?: SelectSubset<T, payment_methodsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payment_methods and returns the data saved in the database.
     * @param {payment_methodsCreateManyAndReturnArgs} args - Arguments to create many Payment_methods.
     * @example
     * // Create many Payment_methods
     * const payment_methods = await prisma.payment_methods.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payment_methods and only return the `payment_method_id`
     * const payment_methodsWithPayment_method_idOnly = await prisma.payment_methods.createManyAndReturn({ 
     *   select: { payment_method_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payment_methodsCreateManyAndReturnArgs>(args?: SelectSubset<T, payment_methodsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment_methods.
     * @param {payment_methodsDeleteArgs} args - Arguments to delete one Payment_methods.
     * @example
     * // Delete one Payment_methods
     * const Payment_methods = await prisma.payment_methods.delete({
     *   where: {
     *     // ... filter to delete one Payment_methods
     *   }
     * })
     * 
     */
    delete<T extends payment_methodsDeleteArgs>(args: SelectSubset<T, payment_methodsDeleteArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment_methods.
     * @param {payment_methodsUpdateArgs} args - Arguments to update one Payment_methods.
     * @example
     * // Update one Payment_methods
     * const payment_methods = await prisma.payment_methods.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payment_methodsUpdateArgs>(args: SelectSubset<T, payment_methodsUpdateArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payment_methods.
     * @param {payment_methodsDeleteManyArgs} args - Arguments to filter Payment_methods to delete.
     * @example
     * // Delete a few Payment_methods
     * const { count } = await prisma.payment_methods.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payment_methodsDeleteManyArgs>(args?: SelectSubset<T, payment_methodsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_methods
     * const payment_methods = await prisma.payment_methods.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payment_methodsUpdateManyArgs>(args: SelectSubset<T, payment_methodsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment_methods.
     * @param {payment_methodsUpsertArgs} args - Arguments to update or create a Payment_methods.
     * @example
     * // Update or create a Payment_methods
     * const payment_methods = await prisma.payment_methods.upsert({
     *   create: {
     *     // ... data to create a Payment_methods
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_methods we want to update
     *   }
     * })
     */
    upsert<T extends payment_methodsUpsertArgs>(args: SelectSubset<T, payment_methodsUpsertArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsCountArgs} args - Arguments to filter Payment_methods to count.
     * @example
     * // Count the number of Payment_methods
     * const count = await prisma.payment_methods.count({
     *   where: {
     *     // ... the filter for the Payment_methods we want to count
     *   }
     * })
    **/
    count<T extends payment_methodsCountArgs>(
      args?: Subset<T, payment_methodsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_methodsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_methodsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_methodsAggregateArgs>(args: Subset<T, Payment_methodsAggregateArgs>): Prisma.PrismaPromise<GetPayment_methodsAggregateType<T>>

    /**
     * Group by Payment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_methodsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_methodsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_methodsGroupByArgs['orderBy'] }
        : { orderBy?: payment_methodsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_methodsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_methodsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_methods model
   */
  readonly fields: payment_methodsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_methods.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_methodsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order_payments<T extends payment_methods$order_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, payment_methods$order_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payment_methods model
   */ 
  interface payment_methodsFieldRefs {
    readonly payment_method_id: FieldRef<"payment_methods", 'String'>
    readonly method_name: FieldRef<"payment_methods", 'String'>
    readonly description: FieldRef<"payment_methods", 'String'>
    readonly created_at: FieldRef<"payment_methods", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payment_methods findUnique
   */
  export type payment_methodsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods findUniqueOrThrow
   */
  export type payment_methodsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods findFirst
   */
  export type payment_methodsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodsScalarFieldEnum | Payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_methods findFirstOrThrow
   */
  export type payment_methodsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_methods.
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_methods.
     */
    distinct?: Payment_methodsScalarFieldEnum | Payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_methods findMany
   */
  export type payment_methodsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter, which payment_methods to fetch.
     */
    where?: payment_methodsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_methods to fetch.
     */
    orderBy?: payment_methodsOrderByWithRelationInput | payment_methodsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_methods.
     */
    cursor?: payment_methodsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_methods.
     */
    skip?: number
    distinct?: Payment_methodsScalarFieldEnum | Payment_methodsScalarFieldEnum[]
  }

  /**
   * payment_methods create
   */
  export type payment_methodsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_methods.
     */
    data: XOR<payment_methodsCreateInput, payment_methodsUncheckedCreateInput>
  }

  /**
   * payment_methods createMany
   */
  export type payment_methodsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodsCreateManyInput | payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_methods createManyAndReturn
   */
  export type payment_methodsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many payment_methods.
     */
    data: payment_methodsCreateManyInput | payment_methodsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payment_methods update
   */
  export type payment_methodsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_methods.
     */
    data: XOR<payment_methodsUpdateInput, payment_methodsUncheckedUpdateInput>
    /**
     * Choose, which payment_methods to update.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods updateMany
   */
  export type payment_methodsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_methods.
     */
    data: XOR<payment_methodsUpdateManyMutationInput, payment_methodsUncheckedUpdateManyInput>
    /**
     * Filter which payment_methods to update
     */
    where?: payment_methodsWhereInput
  }

  /**
   * payment_methods upsert
   */
  export type payment_methodsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_methods to update in case it exists.
     */
    where: payment_methodsWhereUniqueInput
    /**
     * In case the payment_methods found by the `where` argument doesn't exist, create a new payment_methods with this data.
     */
    create: XOR<payment_methodsCreateInput, payment_methodsUncheckedCreateInput>
    /**
     * In case the payment_methods was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_methodsUpdateInput, payment_methodsUncheckedUpdateInput>
  }

  /**
   * payment_methods delete
   */
  export type payment_methodsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
    /**
     * Filter which payment_methods to delete.
     */
    where: payment_methodsWhereUniqueInput
  }

  /**
   * payment_methods deleteMany
   */
  export type payment_methodsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_methods to delete
     */
    where?: payment_methodsWhereInput
  }

  /**
   * payment_methods.order_payments
   */
  export type payment_methods$order_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    where?: order_paymentsWhereInput
    orderBy?: order_paymentsOrderByWithRelationInput | order_paymentsOrderByWithRelationInput[]
    cursor?: order_paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_paymentsScalarFieldEnum | Order_paymentsScalarFieldEnum[]
  }

  /**
   * payment_methods without action
   */
  export type payment_methodsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_methods
     */
    select?: payment_methodsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_methodsInclude<ExtArgs> | null
  }


  /**
   * Model order_payments
   */

  export type AggregateOrder_payments = {
    _count: Order_paymentsCountAggregateOutputType | null
    _avg: Order_paymentsAvgAggregateOutputType | null
    _sum: Order_paymentsSumAggregateOutputType | null
    _min: Order_paymentsMinAggregateOutputType | null
    _max: Order_paymentsMaxAggregateOutputType | null
  }

  export type Order_paymentsAvgAggregateOutputType = {
    order_id: number | null
    amount: Decimal | null
  }

  export type Order_paymentsSumAggregateOutputType = {
    order_id: number | null
    amount: Decimal | null
  }

  export type Order_paymentsMinAggregateOutputType = {
    order_payment_id: string | null
    order_id: number | null
    payment_method_id: string | null
    amount: Decimal | null
    payment_date: Date | null
    reference_no: string | null
    notes: string | null
  }

  export type Order_paymentsMaxAggregateOutputType = {
    order_payment_id: string | null
    order_id: number | null
    payment_method_id: string | null
    amount: Decimal | null
    payment_date: Date | null
    reference_no: string | null
    notes: string | null
  }

  export type Order_paymentsCountAggregateOutputType = {
    order_payment_id: number
    order_id: number
    payment_method_id: number
    amount: number
    payment_date: number
    reference_no: number
    notes: number
    _all: number
  }


  export type Order_paymentsAvgAggregateInputType = {
    order_id?: true
    amount?: true
  }

  export type Order_paymentsSumAggregateInputType = {
    order_id?: true
    amount?: true
  }

  export type Order_paymentsMinAggregateInputType = {
    order_payment_id?: true
    order_id?: true
    payment_method_id?: true
    amount?: true
    payment_date?: true
    reference_no?: true
    notes?: true
  }

  export type Order_paymentsMaxAggregateInputType = {
    order_payment_id?: true
    order_id?: true
    payment_method_id?: true
    amount?: true
    payment_date?: true
    reference_no?: true
    notes?: true
  }

  export type Order_paymentsCountAggregateInputType = {
    order_payment_id?: true
    order_id?: true
    payment_method_id?: true
    amount?: true
    payment_date?: true
    reference_no?: true
    notes?: true
    _all?: true
  }

  export type Order_paymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_payments to aggregate.
     */
    where?: order_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_payments to fetch.
     */
    orderBy?: order_paymentsOrderByWithRelationInput | order_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_payments
    **/
    _count?: true | Order_paymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_paymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_paymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_paymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_paymentsMaxAggregateInputType
  }

  export type GetOrder_paymentsAggregateType<T extends Order_paymentsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_payments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_payments[P]>
      : GetScalarType<T[P], AggregateOrder_payments[P]>
  }




  export type order_paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_paymentsWhereInput
    orderBy?: order_paymentsOrderByWithAggregationInput | order_paymentsOrderByWithAggregationInput[]
    by: Order_paymentsScalarFieldEnum[] | Order_paymentsScalarFieldEnum
    having?: order_paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_paymentsCountAggregateInputType | true
    _avg?: Order_paymentsAvgAggregateInputType
    _sum?: Order_paymentsSumAggregateInputType
    _min?: Order_paymentsMinAggregateInputType
    _max?: Order_paymentsMaxAggregateInputType
  }

  export type Order_paymentsGroupByOutputType = {
    order_payment_id: string
    order_id: number
    payment_method_id: string
    amount: Decimal
    payment_date: Date
    reference_no: string | null
    notes: string | null
    _count: Order_paymentsCountAggregateOutputType | null
    _avg: Order_paymentsAvgAggregateOutputType | null
    _sum: Order_paymentsSumAggregateOutputType | null
    _min: Order_paymentsMinAggregateOutputType | null
    _max: Order_paymentsMaxAggregateOutputType | null
  }

  type GetOrder_paymentsGroupByPayload<T extends order_paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_paymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_paymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_paymentsGroupByOutputType[P]>
            : GetScalarType<T[P], Order_paymentsGroupByOutputType[P]>
        }
      >
    >


  export type order_paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_payment_id?: boolean
    order_id?: boolean
    payment_method_id?: boolean
    amount?: boolean
    payment_date?: boolean
    reference_no?: boolean
    notes?: boolean
    order?: boolean | ordersDefaultArgs<ExtArgs>
    payment_methods?: boolean | payment_methodsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_payments"]>

  export type order_paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_payment_id?: boolean
    order_id?: boolean
    payment_method_id?: boolean
    amount?: boolean
    payment_date?: boolean
    reference_no?: boolean
    notes?: boolean
    order?: boolean | ordersDefaultArgs<ExtArgs>
    payment_methods?: boolean | payment_methodsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_payments"]>

  export type order_paymentsSelectScalar = {
    order_payment_id?: boolean
    order_id?: boolean
    payment_method_id?: boolean
    amount?: boolean
    payment_date?: boolean
    reference_no?: boolean
    notes?: boolean
  }

  export type order_paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ordersDefaultArgs<ExtArgs>
    payment_methods?: boolean | payment_methodsDefaultArgs<ExtArgs>
  }
  export type order_paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | ordersDefaultArgs<ExtArgs>
    payment_methods?: boolean | payment_methodsDefaultArgs<ExtArgs>
  }

  export type $order_paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_payments"
    objects: {
      order: Prisma.$ordersPayload<ExtArgs>
      payment_methods: Prisma.$payment_methodsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      order_payment_id: string
      order_id: number
      payment_method_id: string
      amount: Prisma.Decimal
      payment_date: Date
      reference_no: string | null
      notes: string | null
    }, ExtArgs["result"]["order_payments"]>
    composites: {}
  }

  type order_paymentsGetPayload<S extends boolean | null | undefined | order_paymentsDefaultArgs> = $Result.GetResult<Prisma.$order_paymentsPayload, S>

  type order_paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_paymentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Order_paymentsCountAggregateInputType | true
    }

  export interface order_paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_payments'], meta: { name: 'order_payments' } }
    /**
     * Find zero or one Order_payments that matches the filter.
     * @param {order_paymentsFindUniqueArgs} args - Arguments to find a Order_payments
     * @example
     * // Get one Order_payments
     * const order_payments = await prisma.order_payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends order_paymentsFindUniqueArgs>(args: SelectSubset<T, order_paymentsFindUniqueArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order_payments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {order_paymentsFindUniqueOrThrowArgs} args - Arguments to find a Order_payments
     * @example
     * // Get one Order_payments
     * const order_payments = await prisma.order_payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends order_paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, order_paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_paymentsFindFirstArgs} args - Arguments to find a Order_payments
     * @example
     * // Get one Order_payments
     * const order_payments = await prisma.order_payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends order_paymentsFindFirstArgs>(args?: SelectSubset<T, order_paymentsFindFirstArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order_payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_paymentsFindFirstOrThrowArgs} args - Arguments to find a Order_payments
     * @example
     * // Get one Order_payments
     * const order_payments = await prisma.order_payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends order_paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, order_paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Order_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_payments
     * const order_payments = await prisma.order_payments.findMany()
     * 
     * // Get first 10 Order_payments
     * const order_payments = await prisma.order_payments.findMany({ take: 10 })
     * 
     * // Only select the `order_payment_id`
     * const order_paymentsWithOrder_payment_idOnly = await prisma.order_payments.findMany({ select: { order_payment_id: true } })
     * 
     */
    findMany<T extends order_paymentsFindManyArgs>(args?: SelectSubset<T, order_paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order_payments.
     * @param {order_paymentsCreateArgs} args - Arguments to create a Order_payments.
     * @example
     * // Create one Order_payments
     * const Order_payments = await prisma.order_payments.create({
     *   data: {
     *     // ... data to create a Order_payments
     *   }
     * })
     * 
     */
    create<T extends order_paymentsCreateArgs>(args: SelectSubset<T, order_paymentsCreateArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Order_payments.
     * @param {order_paymentsCreateManyArgs} args - Arguments to create many Order_payments.
     * @example
     * // Create many Order_payments
     * const order_payments = await prisma.order_payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends order_paymentsCreateManyArgs>(args?: SelectSubset<T, order_paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Order_payments and returns the data saved in the database.
     * @param {order_paymentsCreateManyAndReturnArgs} args - Arguments to create many Order_payments.
     * @example
     * // Create many Order_payments
     * const order_payments = await prisma.order_payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Order_payments and only return the `order_payment_id`
     * const order_paymentsWithOrder_payment_idOnly = await prisma.order_payments.createManyAndReturn({ 
     *   select: { order_payment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends order_paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, order_paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order_payments.
     * @param {order_paymentsDeleteArgs} args - Arguments to delete one Order_payments.
     * @example
     * // Delete one Order_payments
     * const Order_payments = await prisma.order_payments.delete({
     *   where: {
     *     // ... filter to delete one Order_payments
     *   }
     * })
     * 
     */
    delete<T extends order_paymentsDeleteArgs>(args: SelectSubset<T, order_paymentsDeleteArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order_payments.
     * @param {order_paymentsUpdateArgs} args - Arguments to update one Order_payments.
     * @example
     * // Update one Order_payments
     * const order_payments = await prisma.order_payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends order_paymentsUpdateArgs>(args: SelectSubset<T, order_paymentsUpdateArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Order_payments.
     * @param {order_paymentsDeleteManyArgs} args - Arguments to filter Order_payments to delete.
     * @example
     * // Delete a few Order_payments
     * const { count } = await prisma.order_payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends order_paymentsDeleteManyArgs>(args?: SelectSubset<T, order_paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_payments
     * const order_payments = await prisma.order_payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends order_paymentsUpdateManyArgs>(args: SelectSubset<T, order_paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_payments.
     * @param {order_paymentsUpsertArgs} args - Arguments to update or create a Order_payments.
     * @example
     * // Update or create a Order_payments
     * const order_payments = await prisma.order_payments.upsert({
     *   create: {
     *     // ... data to create a Order_payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_payments we want to update
     *   }
     * })
     */
    upsert<T extends order_paymentsUpsertArgs>(args: SelectSubset<T, order_paymentsUpsertArgs<ExtArgs>>): Prisma__order_paymentsClient<$Result.GetResult<Prisma.$order_paymentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Order_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_paymentsCountArgs} args - Arguments to filter Order_payments to count.
     * @example
     * // Count the number of Order_payments
     * const count = await prisma.order_payments.count({
     *   where: {
     *     // ... the filter for the Order_payments we want to count
     *   }
     * })
    **/
    count<T extends order_paymentsCountArgs>(
      args?: Subset<T, order_paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_paymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_paymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_paymentsAggregateArgs>(args: Subset<T, Order_paymentsAggregateArgs>): Prisma.PrismaPromise<GetOrder_paymentsAggregateType<T>>

    /**
     * Group by Order_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_paymentsGroupByArgs['orderBy'] }
        : { orderBy?: order_paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_paymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_payments model
   */
  readonly fields: order_paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordersDefaultArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payment_methods<T extends payment_methodsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, payment_methodsDefaultArgs<ExtArgs>>): Prisma__payment_methodsClient<$Result.GetResult<Prisma.$payment_methodsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the order_payments model
   */ 
  interface order_paymentsFieldRefs {
    readonly order_payment_id: FieldRef<"order_payments", 'String'>
    readonly order_id: FieldRef<"order_payments", 'Int'>
    readonly payment_method_id: FieldRef<"order_payments", 'String'>
    readonly amount: FieldRef<"order_payments", 'Decimal'>
    readonly payment_date: FieldRef<"order_payments", 'DateTime'>
    readonly reference_no: FieldRef<"order_payments", 'String'>
    readonly notes: FieldRef<"order_payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * order_payments findUnique
   */
  export type order_paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * Filter, which order_payments to fetch.
     */
    where: order_paymentsWhereUniqueInput
  }

  /**
   * order_payments findUniqueOrThrow
   */
  export type order_paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * Filter, which order_payments to fetch.
     */
    where: order_paymentsWhereUniqueInput
  }

  /**
   * order_payments findFirst
   */
  export type order_paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * Filter, which order_payments to fetch.
     */
    where?: order_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_payments to fetch.
     */
    orderBy?: order_paymentsOrderByWithRelationInput | order_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_payments.
     */
    cursor?: order_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_payments.
     */
    distinct?: Order_paymentsScalarFieldEnum | Order_paymentsScalarFieldEnum[]
  }

  /**
   * order_payments findFirstOrThrow
   */
  export type order_paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * Filter, which order_payments to fetch.
     */
    where?: order_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_payments to fetch.
     */
    orderBy?: order_paymentsOrderByWithRelationInput | order_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_payments.
     */
    cursor?: order_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_payments.
     */
    distinct?: Order_paymentsScalarFieldEnum | Order_paymentsScalarFieldEnum[]
  }

  /**
   * order_payments findMany
   */
  export type order_paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * Filter, which order_payments to fetch.
     */
    where?: order_paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_payments to fetch.
     */
    orderBy?: order_paymentsOrderByWithRelationInput | order_paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_payments.
     */
    cursor?: order_paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_payments.
     */
    skip?: number
    distinct?: Order_paymentsScalarFieldEnum | Order_paymentsScalarFieldEnum[]
  }

  /**
   * order_payments create
   */
  export type order_paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a order_payments.
     */
    data: XOR<order_paymentsCreateInput, order_paymentsUncheckedCreateInput>
  }

  /**
   * order_payments createMany
   */
  export type order_paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_payments.
     */
    data: order_paymentsCreateManyInput | order_paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * order_payments createManyAndReturn
   */
  export type order_paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many order_payments.
     */
    data: order_paymentsCreateManyInput | order_paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * order_payments update
   */
  export type order_paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a order_payments.
     */
    data: XOR<order_paymentsUpdateInput, order_paymentsUncheckedUpdateInput>
    /**
     * Choose, which order_payments to update.
     */
    where: order_paymentsWhereUniqueInput
  }

  /**
   * order_payments updateMany
   */
  export type order_paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_payments.
     */
    data: XOR<order_paymentsUpdateManyMutationInput, order_paymentsUncheckedUpdateManyInput>
    /**
     * Filter which order_payments to update
     */
    where?: order_paymentsWhereInput
  }

  /**
   * order_payments upsert
   */
  export type order_paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the order_payments to update in case it exists.
     */
    where: order_paymentsWhereUniqueInput
    /**
     * In case the order_payments found by the `where` argument doesn't exist, create a new order_payments with this data.
     */
    create: XOR<order_paymentsCreateInput, order_paymentsUncheckedCreateInput>
    /**
     * In case the order_payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_paymentsUpdateInput, order_paymentsUncheckedUpdateInput>
  }

  /**
   * order_payments delete
   */
  export type order_paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
    /**
     * Filter which order_payments to delete.
     */
    where: order_paymentsWhereUniqueInput
  }

  /**
   * order_payments deleteMany
   */
  export type order_paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_payments to delete
     */
    where?: order_paymentsWhereInput
  }

  /**
   * order_payments without action
   */
  export type order_paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_payments
     */
    select?: order_paymentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: order_paymentsInclude<ExtArgs> | null
  }


  /**
   * Model returns
   */

  export type AggregateReturns = {
    _count: ReturnsCountAggregateOutputType | null
    _avg: ReturnsAvgAggregateOutputType | null
    _sum: ReturnsSumAggregateOutputType | null
    _min: ReturnsMinAggregateOutputType | null
    _max: ReturnsMaxAggregateOutputType | null
  }

  export type ReturnsAvgAggregateOutputType = {
    return_id: number | null
    order_id: number | null
    refund_amount: Decimal | null
  }

  export type ReturnsSumAggregateOutputType = {
    return_id: number | null
    order_id: number | null
    refund_amount: Decimal | null
  }

  export type ReturnsMinAggregateOutputType = {
    return_id: number | null
    order_id: number | null
    return_date: Date | null
    status: string | null
    refund_amount: Decimal | null
  }

  export type ReturnsMaxAggregateOutputType = {
    return_id: number | null
    order_id: number | null
    return_date: Date | null
    status: string | null
    refund_amount: Decimal | null
  }

  export type ReturnsCountAggregateOutputType = {
    return_id: number
    order_id: number
    return_date: number
    status: number
    refund_amount: number
    _all: number
  }


  export type ReturnsAvgAggregateInputType = {
    return_id?: true
    order_id?: true
    refund_amount?: true
  }

  export type ReturnsSumAggregateInputType = {
    return_id?: true
    order_id?: true
    refund_amount?: true
  }

  export type ReturnsMinAggregateInputType = {
    return_id?: true
    order_id?: true
    return_date?: true
    status?: true
    refund_amount?: true
  }

  export type ReturnsMaxAggregateInputType = {
    return_id?: true
    order_id?: true
    return_date?: true
    status?: true
    refund_amount?: true
  }

  export type ReturnsCountAggregateInputType = {
    return_id?: true
    order_id?: true
    return_date?: true
    status?: true
    refund_amount?: true
    _all?: true
  }

  export type ReturnsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which returns to aggregate.
     */
    where?: returnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of returns to fetch.
     */
    orderBy?: returnsOrderByWithRelationInput | returnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: returnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` returns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned returns
    **/
    _count?: true | ReturnsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnsMaxAggregateInputType
  }

  export type GetReturnsAggregateType<T extends ReturnsAggregateArgs> = {
        [P in keyof T & keyof AggregateReturns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturns[P]>
      : GetScalarType<T[P], AggregateReturns[P]>
  }




  export type returnsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: returnsWhereInput
    orderBy?: returnsOrderByWithAggregationInput | returnsOrderByWithAggregationInput[]
    by: ReturnsScalarFieldEnum[] | ReturnsScalarFieldEnum
    having?: returnsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnsCountAggregateInputType | true
    _avg?: ReturnsAvgAggregateInputType
    _sum?: ReturnsSumAggregateInputType
    _min?: ReturnsMinAggregateInputType
    _max?: ReturnsMaxAggregateInputType
  }

  export type ReturnsGroupByOutputType = {
    return_id: number
    order_id: number | null
    return_date: Date
    status: string
    refund_amount: Decimal
    _count: ReturnsCountAggregateOutputType | null
    _avg: ReturnsAvgAggregateOutputType | null
    _sum: ReturnsSumAggregateOutputType | null
    _min: ReturnsMinAggregateOutputType | null
    _max: ReturnsMaxAggregateOutputType | null
  }

  type GetReturnsGroupByPayload<T extends returnsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnsGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnsGroupByOutputType[P]>
        }
      >
    >


  export type returnsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    return_id?: boolean
    order_id?: boolean
    return_date?: boolean
    status?: boolean
    refund_amount?: boolean
    order?: boolean | returns$orderArgs<ExtArgs>
    return_items?: boolean | returns$return_itemsArgs<ExtArgs>
    inventory_transactions?: boolean | returns$inventory_transactionsArgs<ExtArgs>
    _count?: boolean | ReturnsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returns"]>

  export type returnsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    return_id?: boolean
    order_id?: boolean
    return_date?: boolean
    status?: boolean
    refund_amount?: boolean
    order?: boolean | returns$orderArgs<ExtArgs>
  }, ExtArgs["result"]["returns"]>

  export type returnsSelectScalar = {
    return_id?: boolean
    order_id?: boolean
    return_date?: boolean
    status?: boolean
    refund_amount?: boolean
  }

  export type returnsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | returns$orderArgs<ExtArgs>
    return_items?: boolean | returns$return_itemsArgs<ExtArgs>
    inventory_transactions?: boolean | returns$inventory_transactionsArgs<ExtArgs>
    _count?: boolean | ReturnsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type returnsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | returns$orderArgs<ExtArgs>
  }

  export type $returnsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "returns"
    objects: {
      order: Prisma.$ordersPayload<ExtArgs> | null
      return_items: Prisma.$return_itemsPayload<ExtArgs>[]
      inventory_transactions: Prisma.$inventory_transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      return_id: number
      order_id: number | null
      return_date: Date
      status: string
      refund_amount: Prisma.Decimal
    }, ExtArgs["result"]["returns"]>
    composites: {}
  }

  type returnsGetPayload<S extends boolean | null | undefined | returnsDefaultArgs> = $Result.GetResult<Prisma.$returnsPayload, S>

  type returnsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<returnsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReturnsCountAggregateInputType | true
    }

  export interface returnsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['returns'], meta: { name: 'returns' } }
    /**
     * Find zero or one Returns that matches the filter.
     * @param {returnsFindUniqueArgs} args - Arguments to find a Returns
     * @example
     * // Get one Returns
     * const returns = await prisma.returns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends returnsFindUniqueArgs>(args: SelectSubset<T, returnsFindUniqueArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Returns that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {returnsFindUniqueOrThrowArgs} args - Arguments to find a Returns
     * @example
     * // Get one Returns
     * const returns = await prisma.returns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends returnsFindUniqueOrThrowArgs>(args: SelectSubset<T, returnsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Returns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {returnsFindFirstArgs} args - Arguments to find a Returns
     * @example
     * // Get one Returns
     * const returns = await prisma.returns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends returnsFindFirstArgs>(args?: SelectSubset<T, returnsFindFirstArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Returns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {returnsFindFirstOrThrowArgs} args - Arguments to find a Returns
     * @example
     * // Get one Returns
     * const returns = await prisma.returns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends returnsFindFirstOrThrowArgs>(args?: SelectSubset<T, returnsFindFirstOrThrowArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Returns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {returnsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Returns
     * const returns = await prisma.returns.findMany()
     * 
     * // Get first 10 Returns
     * const returns = await prisma.returns.findMany({ take: 10 })
     * 
     * // Only select the `return_id`
     * const returnsWithReturn_idOnly = await prisma.returns.findMany({ select: { return_id: true } })
     * 
     */
    findMany<T extends returnsFindManyArgs>(args?: SelectSubset<T, returnsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Returns.
     * @param {returnsCreateArgs} args - Arguments to create a Returns.
     * @example
     * // Create one Returns
     * const Returns = await prisma.returns.create({
     *   data: {
     *     // ... data to create a Returns
     *   }
     * })
     * 
     */
    create<T extends returnsCreateArgs>(args: SelectSubset<T, returnsCreateArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Returns.
     * @param {returnsCreateManyArgs} args - Arguments to create many Returns.
     * @example
     * // Create many Returns
     * const returns = await prisma.returns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends returnsCreateManyArgs>(args?: SelectSubset<T, returnsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Returns and returns the data saved in the database.
     * @param {returnsCreateManyAndReturnArgs} args - Arguments to create many Returns.
     * @example
     * // Create many Returns
     * const returns = await prisma.returns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Returns and only return the `return_id`
     * const returnsWithReturn_idOnly = await prisma.returns.createManyAndReturn({ 
     *   select: { return_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends returnsCreateManyAndReturnArgs>(args?: SelectSubset<T, returnsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Returns.
     * @param {returnsDeleteArgs} args - Arguments to delete one Returns.
     * @example
     * // Delete one Returns
     * const Returns = await prisma.returns.delete({
     *   where: {
     *     // ... filter to delete one Returns
     *   }
     * })
     * 
     */
    delete<T extends returnsDeleteArgs>(args: SelectSubset<T, returnsDeleteArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Returns.
     * @param {returnsUpdateArgs} args - Arguments to update one Returns.
     * @example
     * // Update one Returns
     * const returns = await prisma.returns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends returnsUpdateArgs>(args: SelectSubset<T, returnsUpdateArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Returns.
     * @param {returnsDeleteManyArgs} args - Arguments to filter Returns to delete.
     * @example
     * // Delete a few Returns
     * const { count } = await prisma.returns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends returnsDeleteManyArgs>(args?: SelectSubset<T, returnsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Returns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {returnsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Returns
     * const returns = await prisma.returns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends returnsUpdateManyArgs>(args: SelectSubset<T, returnsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Returns.
     * @param {returnsUpsertArgs} args - Arguments to update or create a Returns.
     * @example
     * // Update or create a Returns
     * const returns = await prisma.returns.upsert({
     *   create: {
     *     // ... data to create a Returns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Returns we want to update
     *   }
     * })
     */
    upsert<T extends returnsUpsertArgs>(args: SelectSubset<T, returnsUpsertArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Returns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {returnsCountArgs} args - Arguments to filter Returns to count.
     * @example
     * // Count the number of Returns
     * const count = await prisma.returns.count({
     *   where: {
     *     // ... the filter for the Returns we want to count
     *   }
     * })
    **/
    count<T extends returnsCountArgs>(
      args?: Subset<T, returnsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Returns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnsAggregateArgs>(args: Subset<T, ReturnsAggregateArgs>): Prisma.PrismaPromise<GetReturnsAggregateType<T>>

    /**
     * Group by Returns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {returnsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends returnsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: returnsGroupByArgs['orderBy'] }
        : { orderBy?: returnsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, returnsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the returns model
   */
  readonly fields: returnsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for returns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__returnsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends returns$orderArgs<ExtArgs> = {}>(args?: Subset<T, returns$orderArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    return_items<T extends returns$return_itemsArgs<ExtArgs> = {}>(args?: Subset<T, returns$return_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "findMany"> | Null>
    inventory_transactions<T extends returns$inventory_transactionsArgs<ExtArgs> = {}>(args?: Subset<T, returns$inventory_transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the returns model
   */ 
  interface returnsFieldRefs {
    readonly return_id: FieldRef<"returns", 'Int'>
    readonly order_id: FieldRef<"returns", 'Int'>
    readonly return_date: FieldRef<"returns", 'DateTime'>
    readonly status: FieldRef<"returns", 'String'>
    readonly refund_amount: FieldRef<"returns", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * returns findUnique
   */
  export type returnsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * Filter, which returns to fetch.
     */
    where: returnsWhereUniqueInput
  }

  /**
   * returns findUniqueOrThrow
   */
  export type returnsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * Filter, which returns to fetch.
     */
    where: returnsWhereUniqueInput
  }

  /**
   * returns findFirst
   */
  export type returnsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * Filter, which returns to fetch.
     */
    where?: returnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of returns to fetch.
     */
    orderBy?: returnsOrderByWithRelationInput | returnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for returns.
     */
    cursor?: returnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` returns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of returns.
     */
    distinct?: ReturnsScalarFieldEnum | ReturnsScalarFieldEnum[]
  }

  /**
   * returns findFirstOrThrow
   */
  export type returnsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * Filter, which returns to fetch.
     */
    where?: returnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of returns to fetch.
     */
    orderBy?: returnsOrderByWithRelationInput | returnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for returns.
     */
    cursor?: returnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` returns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of returns.
     */
    distinct?: ReturnsScalarFieldEnum | ReturnsScalarFieldEnum[]
  }

  /**
   * returns findMany
   */
  export type returnsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * Filter, which returns to fetch.
     */
    where?: returnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of returns to fetch.
     */
    orderBy?: returnsOrderByWithRelationInput | returnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing returns.
     */
    cursor?: returnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` returns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` returns.
     */
    skip?: number
    distinct?: ReturnsScalarFieldEnum | ReturnsScalarFieldEnum[]
  }

  /**
   * returns create
   */
  export type returnsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * The data needed to create a returns.
     */
    data?: XOR<returnsCreateInput, returnsUncheckedCreateInput>
  }

  /**
   * returns createMany
   */
  export type returnsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many returns.
     */
    data: returnsCreateManyInput | returnsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * returns createManyAndReturn
   */
  export type returnsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many returns.
     */
    data: returnsCreateManyInput | returnsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * returns update
   */
  export type returnsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * The data needed to update a returns.
     */
    data: XOR<returnsUpdateInput, returnsUncheckedUpdateInput>
    /**
     * Choose, which returns to update.
     */
    where: returnsWhereUniqueInput
  }

  /**
   * returns updateMany
   */
  export type returnsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update returns.
     */
    data: XOR<returnsUpdateManyMutationInput, returnsUncheckedUpdateManyInput>
    /**
     * Filter which returns to update
     */
    where?: returnsWhereInput
  }

  /**
   * returns upsert
   */
  export type returnsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * The filter to search for the returns to update in case it exists.
     */
    where: returnsWhereUniqueInput
    /**
     * In case the returns found by the `where` argument doesn't exist, create a new returns with this data.
     */
    create: XOR<returnsCreateInput, returnsUncheckedCreateInput>
    /**
     * In case the returns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<returnsUpdateInput, returnsUncheckedUpdateInput>
  }

  /**
   * returns delete
   */
  export type returnsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    /**
     * Filter which returns to delete.
     */
    where: returnsWhereUniqueInput
  }

  /**
   * returns deleteMany
   */
  export type returnsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which returns to delete
     */
    where?: returnsWhereInput
  }

  /**
   * returns.order
   */
  export type returns$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
  }

  /**
   * returns.return_items
   */
  export type returns$return_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    where?: return_itemsWhereInput
    orderBy?: return_itemsOrderByWithRelationInput | return_itemsOrderByWithRelationInput[]
    cursor?: return_itemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Return_itemsScalarFieldEnum | Return_itemsScalarFieldEnum[]
  }

  /**
   * returns.inventory_transactions
   */
  export type returns$inventory_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    where?: inventory_transactionsWhereInput
    orderBy?: inventory_transactionsOrderByWithRelationInput | inventory_transactionsOrderByWithRelationInput[]
    cursor?: inventory_transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inventory_transactionsScalarFieldEnum | Inventory_transactionsScalarFieldEnum[]
  }

  /**
   * returns without action
   */
  export type returnsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
  }


  /**
   * Model return_items
   */

  export type AggregateReturn_items = {
    _count: Return_itemsCountAggregateOutputType | null
    _avg: Return_itemsAvgAggregateOutputType | null
    _sum: Return_itemsSumAggregateOutputType | null
    _min: Return_itemsMinAggregateOutputType | null
    _max: Return_itemsMaxAggregateOutputType | null
  }

  export type Return_itemsAvgAggregateOutputType = {
    return_id: number | null
    quantity: number | null
    refund_amount: Decimal | null
  }

  export type Return_itemsSumAggregateOutputType = {
    return_id: number | null
    quantity: number | null
    refund_amount: Decimal | null
  }

  export type Return_itemsMinAggregateOutputType = {
    return_item_id: string | null
    return_id: number | null
    product_id: string | null
    quantity: number | null
    refund_amount: Decimal | null
  }

  export type Return_itemsMaxAggregateOutputType = {
    return_item_id: string | null
    return_id: number | null
    product_id: string | null
    quantity: number | null
    refund_amount: Decimal | null
  }

  export type Return_itemsCountAggregateOutputType = {
    return_item_id: number
    return_id: number
    product_id: number
    quantity: number
    refund_amount: number
    _all: number
  }


  export type Return_itemsAvgAggregateInputType = {
    return_id?: true
    quantity?: true
    refund_amount?: true
  }

  export type Return_itemsSumAggregateInputType = {
    return_id?: true
    quantity?: true
    refund_amount?: true
  }

  export type Return_itemsMinAggregateInputType = {
    return_item_id?: true
    return_id?: true
    product_id?: true
    quantity?: true
    refund_amount?: true
  }

  export type Return_itemsMaxAggregateInputType = {
    return_item_id?: true
    return_id?: true
    product_id?: true
    quantity?: true
    refund_amount?: true
  }

  export type Return_itemsCountAggregateInputType = {
    return_item_id?: true
    return_id?: true
    product_id?: true
    quantity?: true
    refund_amount?: true
    _all?: true
  }

  export type Return_itemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_items to aggregate.
     */
    where?: return_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_items to fetch.
     */
    orderBy?: return_itemsOrderByWithRelationInput | return_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: return_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned return_items
    **/
    _count?: true | Return_itemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Return_itemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Return_itemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Return_itemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Return_itemsMaxAggregateInputType
  }

  export type GetReturn_itemsAggregateType<T extends Return_itemsAggregateArgs> = {
        [P in keyof T & keyof AggregateReturn_items]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturn_items[P]>
      : GetScalarType<T[P], AggregateReturn_items[P]>
  }




  export type return_itemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: return_itemsWhereInput
    orderBy?: return_itemsOrderByWithAggregationInput | return_itemsOrderByWithAggregationInput[]
    by: Return_itemsScalarFieldEnum[] | Return_itemsScalarFieldEnum
    having?: return_itemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Return_itemsCountAggregateInputType | true
    _avg?: Return_itemsAvgAggregateInputType
    _sum?: Return_itemsSumAggregateInputType
    _min?: Return_itemsMinAggregateInputType
    _max?: Return_itemsMaxAggregateInputType
  }

  export type Return_itemsGroupByOutputType = {
    return_item_id: string
    return_id: number
    product_id: string
    quantity: number
    refund_amount: Decimal
    _count: Return_itemsCountAggregateOutputType | null
    _avg: Return_itemsAvgAggregateOutputType | null
    _sum: Return_itemsSumAggregateOutputType | null
    _min: Return_itemsMinAggregateOutputType | null
    _max: Return_itemsMaxAggregateOutputType | null
  }

  type GetReturn_itemsGroupByPayload<T extends return_itemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Return_itemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Return_itemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Return_itemsGroupByOutputType[P]>
            : GetScalarType<T[P], Return_itemsGroupByOutputType[P]>
        }
      >
    >


  export type return_itemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    return_item_id?: boolean
    return_id?: boolean
    product_id?: boolean
    quantity?: boolean
    refund_amount?: boolean
    returns?: boolean | returnsDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return_items"]>

  export type return_itemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    return_item_id?: boolean
    return_id?: boolean
    product_id?: boolean
    quantity?: boolean
    refund_amount?: boolean
    returns?: boolean | returnsDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["return_items"]>

  export type return_itemsSelectScalar = {
    return_item_id?: boolean
    return_id?: boolean
    product_id?: boolean
    quantity?: boolean
    refund_amount?: boolean
  }

  export type return_itemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    returns?: boolean | returnsDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }
  export type return_itemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    returns?: boolean | returnsDefaultArgs<ExtArgs>
    product?: boolean | productsDefaultArgs<ExtArgs>
  }

  export type $return_itemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "return_items"
    objects: {
      returns: Prisma.$returnsPayload<ExtArgs>
      product: Prisma.$productsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      return_item_id: string
      return_id: number
      product_id: string
      quantity: number
      refund_amount: Prisma.Decimal
    }, ExtArgs["result"]["return_items"]>
    composites: {}
  }

  type return_itemsGetPayload<S extends boolean | null | undefined | return_itemsDefaultArgs> = $Result.GetResult<Prisma.$return_itemsPayload, S>

  type return_itemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<return_itemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Return_itemsCountAggregateInputType | true
    }

  export interface return_itemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['return_items'], meta: { name: 'return_items' } }
    /**
     * Find zero or one Return_items that matches the filter.
     * @param {return_itemsFindUniqueArgs} args - Arguments to find a Return_items
     * @example
     * // Get one Return_items
     * const return_items = await prisma.return_items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends return_itemsFindUniqueArgs>(args: SelectSubset<T, return_itemsFindUniqueArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Return_items that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {return_itemsFindUniqueOrThrowArgs} args - Arguments to find a Return_items
     * @example
     * // Get one Return_items
     * const return_items = await prisma.return_items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends return_itemsFindUniqueOrThrowArgs>(args: SelectSubset<T, return_itemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Return_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_itemsFindFirstArgs} args - Arguments to find a Return_items
     * @example
     * // Get one Return_items
     * const return_items = await prisma.return_items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends return_itemsFindFirstArgs>(args?: SelectSubset<T, return_itemsFindFirstArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Return_items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_itemsFindFirstOrThrowArgs} args - Arguments to find a Return_items
     * @example
     * // Get one Return_items
     * const return_items = await prisma.return_items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends return_itemsFindFirstOrThrowArgs>(args?: SelectSubset<T, return_itemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Return_items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_itemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Return_items
     * const return_items = await prisma.return_items.findMany()
     * 
     * // Get first 10 Return_items
     * const return_items = await prisma.return_items.findMany({ take: 10 })
     * 
     * // Only select the `return_item_id`
     * const return_itemsWithReturn_item_idOnly = await prisma.return_items.findMany({ select: { return_item_id: true } })
     * 
     */
    findMany<T extends return_itemsFindManyArgs>(args?: SelectSubset<T, return_itemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Return_items.
     * @param {return_itemsCreateArgs} args - Arguments to create a Return_items.
     * @example
     * // Create one Return_items
     * const Return_items = await prisma.return_items.create({
     *   data: {
     *     // ... data to create a Return_items
     *   }
     * })
     * 
     */
    create<T extends return_itemsCreateArgs>(args: SelectSubset<T, return_itemsCreateArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Return_items.
     * @param {return_itemsCreateManyArgs} args - Arguments to create many Return_items.
     * @example
     * // Create many Return_items
     * const return_items = await prisma.return_items.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends return_itemsCreateManyArgs>(args?: SelectSubset<T, return_itemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Return_items and returns the data saved in the database.
     * @param {return_itemsCreateManyAndReturnArgs} args - Arguments to create many Return_items.
     * @example
     * // Create many Return_items
     * const return_items = await prisma.return_items.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Return_items and only return the `return_item_id`
     * const return_itemsWithReturn_item_idOnly = await prisma.return_items.createManyAndReturn({ 
     *   select: { return_item_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends return_itemsCreateManyAndReturnArgs>(args?: SelectSubset<T, return_itemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Return_items.
     * @param {return_itemsDeleteArgs} args - Arguments to delete one Return_items.
     * @example
     * // Delete one Return_items
     * const Return_items = await prisma.return_items.delete({
     *   where: {
     *     // ... filter to delete one Return_items
     *   }
     * })
     * 
     */
    delete<T extends return_itemsDeleteArgs>(args: SelectSubset<T, return_itemsDeleteArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Return_items.
     * @param {return_itemsUpdateArgs} args - Arguments to update one Return_items.
     * @example
     * // Update one Return_items
     * const return_items = await prisma.return_items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends return_itemsUpdateArgs>(args: SelectSubset<T, return_itemsUpdateArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Return_items.
     * @param {return_itemsDeleteManyArgs} args - Arguments to filter Return_items to delete.
     * @example
     * // Delete a few Return_items
     * const { count } = await prisma.return_items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends return_itemsDeleteManyArgs>(args?: SelectSubset<T, return_itemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Return_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_itemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Return_items
     * const return_items = await prisma.return_items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends return_itemsUpdateManyArgs>(args: SelectSubset<T, return_itemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Return_items.
     * @param {return_itemsUpsertArgs} args - Arguments to update or create a Return_items.
     * @example
     * // Update or create a Return_items
     * const return_items = await prisma.return_items.upsert({
     *   create: {
     *     // ... data to create a Return_items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Return_items we want to update
     *   }
     * })
     */
    upsert<T extends return_itemsUpsertArgs>(args: SelectSubset<T, return_itemsUpsertArgs<ExtArgs>>): Prisma__return_itemsClient<$Result.GetResult<Prisma.$return_itemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Return_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_itemsCountArgs} args - Arguments to filter Return_items to count.
     * @example
     * // Count the number of Return_items
     * const count = await prisma.return_items.count({
     *   where: {
     *     // ... the filter for the Return_items we want to count
     *   }
     * })
    **/
    count<T extends return_itemsCountArgs>(
      args?: Subset<T, return_itemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Return_itemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Return_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Return_itemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Return_itemsAggregateArgs>(args: Subset<T, Return_itemsAggregateArgs>): Prisma.PrismaPromise<GetReturn_itemsAggregateType<T>>

    /**
     * Group by Return_items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {return_itemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends return_itemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: return_itemsGroupByArgs['orderBy'] }
        : { orderBy?: return_itemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, return_itemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturn_itemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the return_items model
   */
  readonly fields: return_itemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for return_items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__return_itemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    returns<T extends returnsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, returnsDefaultArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsDefaultArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the return_items model
   */ 
  interface return_itemsFieldRefs {
    readonly return_item_id: FieldRef<"return_items", 'String'>
    readonly return_id: FieldRef<"return_items", 'Int'>
    readonly product_id: FieldRef<"return_items", 'String'>
    readonly quantity: FieldRef<"return_items", 'Int'>
    readonly refund_amount: FieldRef<"return_items", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * return_items findUnique
   */
  export type return_itemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * Filter, which return_items to fetch.
     */
    where: return_itemsWhereUniqueInput
  }

  /**
   * return_items findUniqueOrThrow
   */
  export type return_itemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * Filter, which return_items to fetch.
     */
    where: return_itemsWhereUniqueInput
  }

  /**
   * return_items findFirst
   */
  export type return_itemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * Filter, which return_items to fetch.
     */
    where?: return_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_items to fetch.
     */
    orderBy?: return_itemsOrderByWithRelationInput | return_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_items.
     */
    cursor?: return_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_items.
     */
    distinct?: Return_itemsScalarFieldEnum | Return_itemsScalarFieldEnum[]
  }

  /**
   * return_items findFirstOrThrow
   */
  export type return_itemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * Filter, which return_items to fetch.
     */
    where?: return_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_items to fetch.
     */
    orderBy?: return_itemsOrderByWithRelationInput | return_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for return_items.
     */
    cursor?: return_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of return_items.
     */
    distinct?: Return_itemsScalarFieldEnum | Return_itemsScalarFieldEnum[]
  }

  /**
   * return_items findMany
   */
  export type return_itemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * Filter, which return_items to fetch.
     */
    where?: return_itemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of return_items to fetch.
     */
    orderBy?: return_itemsOrderByWithRelationInput | return_itemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing return_items.
     */
    cursor?: return_itemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` return_items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` return_items.
     */
    skip?: number
    distinct?: Return_itemsScalarFieldEnum | Return_itemsScalarFieldEnum[]
  }

  /**
   * return_items create
   */
  export type return_itemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * The data needed to create a return_items.
     */
    data: XOR<return_itemsCreateInput, return_itemsUncheckedCreateInput>
  }

  /**
   * return_items createMany
   */
  export type return_itemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many return_items.
     */
    data: return_itemsCreateManyInput | return_itemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * return_items createManyAndReturn
   */
  export type return_itemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many return_items.
     */
    data: return_itemsCreateManyInput | return_itemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * return_items update
   */
  export type return_itemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * The data needed to update a return_items.
     */
    data: XOR<return_itemsUpdateInput, return_itemsUncheckedUpdateInput>
    /**
     * Choose, which return_items to update.
     */
    where: return_itemsWhereUniqueInput
  }

  /**
   * return_items updateMany
   */
  export type return_itemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update return_items.
     */
    data: XOR<return_itemsUpdateManyMutationInput, return_itemsUncheckedUpdateManyInput>
    /**
     * Filter which return_items to update
     */
    where?: return_itemsWhereInput
  }

  /**
   * return_items upsert
   */
  export type return_itemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * The filter to search for the return_items to update in case it exists.
     */
    where: return_itemsWhereUniqueInput
    /**
     * In case the return_items found by the `where` argument doesn't exist, create a new return_items with this data.
     */
    create: XOR<return_itemsCreateInput, return_itemsUncheckedCreateInput>
    /**
     * In case the return_items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<return_itemsUpdateInput, return_itemsUncheckedUpdateInput>
  }

  /**
   * return_items delete
   */
  export type return_itemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
    /**
     * Filter which return_items to delete.
     */
    where: return_itemsWhereUniqueInput
  }

  /**
   * return_items deleteMany
   */
  export type return_itemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which return_items to delete
     */
    where?: return_itemsWhereInput
  }

  /**
   * return_items without action
   */
  export type return_itemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the return_items
     */
    select?: return_itemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: return_itemsInclude<ExtArgs> | null
  }


  /**
   * Model inventory_transactions
   */

  export type AggregateInventory_transactions = {
    _count: Inventory_transactionsCountAggregateOutputType | null
    _avg: Inventory_transactionsAvgAggregateOutputType | null
    _sum: Inventory_transactionsSumAggregateOutputType | null
    _min: Inventory_transactionsMinAggregateOutputType | null
    _max: Inventory_transactionsMaxAggregateOutputType | null
  }

  export type Inventory_transactionsAvgAggregateOutputType = {
    quantity_change: number | null
    related_order_id: number | null
    related_return_id: number | null
  }

  export type Inventory_transactionsSumAggregateOutputType = {
    quantity_change: number | null
    related_order_id: number | null
    related_return_id: number | null
  }

  export type Inventory_transactionsMinAggregateOutputType = {
    transaction_id: string | null
    product_id: string | null
    change_type: string | null
    quantity_change: number | null
    related_order_id: number | null
    related_return_id: number | null
    created_at: Date | null
  }

  export type Inventory_transactionsMaxAggregateOutputType = {
    transaction_id: string | null
    product_id: string | null
    change_type: string | null
    quantity_change: number | null
    related_order_id: number | null
    related_return_id: number | null
    created_at: Date | null
  }

  export type Inventory_transactionsCountAggregateOutputType = {
    transaction_id: number
    product_id: number
    change_type: number
    quantity_change: number
    related_order_id: number
    related_return_id: number
    created_at: number
    _all: number
  }


  export type Inventory_transactionsAvgAggregateInputType = {
    quantity_change?: true
    related_order_id?: true
    related_return_id?: true
  }

  export type Inventory_transactionsSumAggregateInputType = {
    quantity_change?: true
    related_order_id?: true
    related_return_id?: true
  }

  export type Inventory_transactionsMinAggregateInputType = {
    transaction_id?: true
    product_id?: true
    change_type?: true
    quantity_change?: true
    related_order_id?: true
    related_return_id?: true
    created_at?: true
  }

  export type Inventory_transactionsMaxAggregateInputType = {
    transaction_id?: true
    product_id?: true
    change_type?: true
    quantity_change?: true
    related_order_id?: true
    related_return_id?: true
    created_at?: true
  }

  export type Inventory_transactionsCountAggregateInputType = {
    transaction_id?: true
    product_id?: true
    change_type?: true
    quantity_change?: true
    related_order_id?: true
    related_return_id?: true
    created_at?: true
    _all?: true
  }

  export type Inventory_transactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory_transactions to aggregate.
     */
    where?: inventory_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_transactions to fetch.
     */
    orderBy?: inventory_transactionsOrderByWithRelationInput | inventory_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inventory_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inventory_transactions
    **/
    _count?: true | Inventory_transactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inventory_transactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inventory_transactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inventory_transactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inventory_transactionsMaxAggregateInputType
  }

  export type GetInventory_transactionsAggregateType<T extends Inventory_transactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory_transactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory_transactions[P]>
      : GetScalarType<T[P], AggregateInventory_transactions[P]>
  }




  export type inventory_transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inventory_transactionsWhereInput
    orderBy?: inventory_transactionsOrderByWithAggregationInput | inventory_transactionsOrderByWithAggregationInput[]
    by: Inventory_transactionsScalarFieldEnum[] | Inventory_transactionsScalarFieldEnum
    having?: inventory_transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inventory_transactionsCountAggregateInputType | true
    _avg?: Inventory_transactionsAvgAggregateInputType
    _sum?: Inventory_transactionsSumAggregateInputType
    _min?: Inventory_transactionsMinAggregateInputType
    _max?: Inventory_transactionsMaxAggregateInputType
  }

  export type Inventory_transactionsGroupByOutputType = {
    transaction_id: string
    product_id: string
    change_type: string
    quantity_change: number
    related_order_id: number | null
    related_return_id: number | null
    created_at: Date
    _count: Inventory_transactionsCountAggregateOutputType | null
    _avg: Inventory_transactionsAvgAggregateOutputType | null
    _sum: Inventory_transactionsSumAggregateOutputType | null
    _min: Inventory_transactionsMinAggregateOutputType | null
    _max: Inventory_transactionsMaxAggregateOutputType | null
  }

  type GetInventory_transactionsGroupByPayload<T extends inventory_transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inventory_transactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inventory_transactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inventory_transactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Inventory_transactionsGroupByOutputType[P]>
        }
      >
    >


  export type inventory_transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transaction_id?: boolean
    product_id?: boolean
    change_type?: boolean
    quantity_change?: boolean
    related_order_id?: boolean
    related_return_id?: boolean
    created_at?: boolean
    product?: boolean | productsDefaultArgs<ExtArgs>
    order?: boolean | inventory_transactions$orderArgs<ExtArgs>
    returns?: boolean | inventory_transactions$returnsArgs<ExtArgs>
  }, ExtArgs["result"]["inventory_transactions"]>

  export type inventory_transactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    transaction_id?: boolean
    product_id?: boolean
    change_type?: boolean
    quantity_change?: boolean
    related_order_id?: boolean
    related_return_id?: boolean
    created_at?: boolean
    product?: boolean | productsDefaultArgs<ExtArgs>
    order?: boolean | inventory_transactions$orderArgs<ExtArgs>
    returns?: boolean | inventory_transactions$returnsArgs<ExtArgs>
  }, ExtArgs["result"]["inventory_transactions"]>

  export type inventory_transactionsSelectScalar = {
    transaction_id?: boolean
    product_id?: boolean
    change_type?: boolean
    quantity_change?: boolean
    related_order_id?: boolean
    related_return_id?: boolean
    created_at?: boolean
  }

  export type inventory_transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productsDefaultArgs<ExtArgs>
    order?: boolean | inventory_transactions$orderArgs<ExtArgs>
    returns?: boolean | inventory_transactions$returnsArgs<ExtArgs>
  }
  export type inventory_transactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | productsDefaultArgs<ExtArgs>
    order?: boolean | inventory_transactions$orderArgs<ExtArgs>
    returns?: boolean | inventory_transactions$returnsArgs<ExtArgs>
  }

  export type $inventory_transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inventory_transactions"
    objects: {
      product: Prisma.$productsPayload<ExtArgs>
      order: Prisma.$ordersPayload<ExtArgs> | null
      returns: Prisma.$returnsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      transaction_id: string
      product_id: string
      change_type: string
      quantity_change: number
      related_order_id: number | null
      related_return_id: number | null
      created_at: Date
    }, ExtArgs["result"]["inventory_transactions"]>
    composites: {}
  }

  type inventory_transactionsGetPayload<S extends boolean | null | undefined | inventory_transactionsDefaultArgs> = $Result.GetResult<Prisma.$inventory_transactionsPayload, S>

  type inventory_transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<inventory_transactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Inventory_transactionsCountAggregateInputType | true
    }

  export interface inventory_transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inventory_transactions'], meta: { name: 'inventory_transactions' } }
    /**
     * Find zero or one Inventory_transactions that matches the filter.
     * @param {inventory_transactionsFindUniqueArgs} args - Arguments to find a Inventory_transactions
     * @example
     * // Get one Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inventory_transactionsFindUniqueArgs>(args: SelectSubset<T, inventory_transactionsFindUniqueArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Inventory_transactions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {inventory_transactionsFindUniqueOrThrowArgs} args - Arguments to find a Inventory_transactions
     * @example
     * // Get one Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inventory_transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, inventory_transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Inventory_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_transactionsFindFirstArgs} args - Arguments to find a Inventory_transactions
     * @example
     * // Get one Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inventory_transactionsFindFirstArgs>(args?: SelectSubset<T, inventory_transactionsFindFirstArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Inventory_transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_transactionsFindFirstOrThrowArgs} args - Arguments to find a Inventory_transactions
     * @example
     * // Get one Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inventory_transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, inventory_transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Inventory_transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.findMany()
     * 
     * // Get first 10 Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.findMany({ take: 10 })
     * 
     * // Only select the `transaction_id`
     * const inventory_transactionsWithTransaction_idOnly = await prisma.inventory_transactions.findMany({ select: { transaction_id: true } })
     * 
     */
    findMany<T extends inventory_transactionsFindManyArgs>(args?: SelectSubset<T, inventory_transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Inventory_transactions.
     * @param {inventory_transactionsCreateArgs} args - Arguments to create a Inventory_transactions.
     * @example
     * // Create one Inventory_transactions
     * const Inventory_transactions = await prisma.inventory_transactions.create({
     *   data: {
     *     // ... data to create a Inventory_transactions
     *   }
     * })
     * 
     */
    create<T extends inventory_transactionsCreateArgs>(args: SelectSubset<T, inventory_transactionsCreateArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Inventory_transactions.
     * @param {inventory_transactionsCreateManyArgs} args - Arguments to create many Inventory_transactions.
     * @example
     * // Create many Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inventory_transactionsCreateManyArgs>(args?: SelectSubset<T, inventory_transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inventory_transactions and returns the data saved in the database.
     * @param {inventory_transactionsCreateManyAndReturnArgs} args - Arguments to create many Inventory_transactions.
     * @example
     * // Create many Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inventory_transactions and only return the `transaction_id`
     * const inventory_transactionsWithTransaction_idOnly = await prisma.inventory_transactions.createManyAndReturn({ 
     *   select: { transaction_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inventory_transactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, inventory_transactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Inventory_transactions.
     * @param {inventory_transactionsDeleteArgs} args - Arguments to delete one Inventory_transactions.
     * @example
     * // Delete one Inventory_transactions
     * const Inventory_transactions = await prisma.inventory_transactions.delete({
     *   where: {
     *     // ... filter to delete one Inventory_transactions
     *   }
     * })
     * 
     */
    delete<T extends inventory_transactionsDeleteArgs>(args: SelectSubset<T, inventory_transactionsDeleteArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Inventory_transactions.
     * @param {inventory_transactionsUpdateArgs} args - Arguments to update one Inventory_transactions.
     * @example
     * // Update one Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inventory_transactionsUpdateArgs>(args: SelectSubset<T, inventory_transactionsUpdateArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Inventory_transactions.
     * @param {inventory_transactionsDeleteManyArgs} args - Arguments to filter Inventory_transactions to delete.
     * @example
     * // Delete a few Inventory_transactions
     * const { count } = await prisma.inventory_transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inventory_transactionsDeleteManyArgs>(args?: SelectSubset<T, inventory_transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventory_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inventory_transactionsUpdateManyArgs>(args: SelectSubset<T, inventory_transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory_transactions.
     * @param {inventory_transactionsUpsertArgs} args - Arguments to update or create a Inventory_transactions.
     * @example
     * // Update or create a Inventory_transactions
     * const inventory_transactions = await prisma.inventory_transactions.upsert({
     *   create: {
     *     // ... data to create a Inventory_transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory_transactions we want to update
     *   }
     * })
     */
    upsert<T extends inventory_transactionsUpsertArgs>(args: SelectSubset<T, inventory_transactionsUpsertArgs<ExtArgs>>): Prisma__inventory_transactionsClient<$Result.GetResult<Prisma.$inventory_transactionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Inventory_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_transactionsCountArgs} args - Arguments to filter Inventory_transactions to count.
     * @example
     * // Count the number of Inventory_transactions
     * const count = await prisma.inventory_transactions.count({
     *   where: {
     *     // ... the filter for the Inventory_transactions we want to count
     *   }
     * })
    **/
    count<T extends inventory_transactionsCountArgs>(
      args?: Subset<T, inventory_transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inventory_transactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inventory_transactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inventory_transactionsAggregateArgs>(args: Subset<T, Inventory_transactionsAggregateArgs>): Prisma.PrismaPromise<GetInventory_transactionsAggregateType<T>>

    /**
     * Group by Inventory_transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inventory_transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inventory_transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inventory_transactionsGroupByArgs['orderBy'] }
        : { orderBy?: inventory_transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inventory_transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventory_transactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inventory_transactions model
   */
  readonly fields: inventory_transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inventory_transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inventory_transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends productsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productsDefaultArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order<T extends inventory_transactions$orderArgs<ExtArgs> = {}>(args?: Subset<T, inventory_transactions$orderArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    returns<T extends inventory_transactions$returnsArgs<ExtArgs> = {}>(args?: Subset<T, inventory_transactions$returnsArgs<ExtArgs>>): Prisma__returnsClient<$Result.GetResult<Prisma.$returnsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inventory_transactions model
   */ 
  interface inventory_transactionsFieldRefs {
    readonly transaction_id: FieldRef<"inventory_transactions", 'String'>
    readonly product_id: FieldRef<"inventory_transactions", 'String'>
    readonly change_type: FieldRef<"inventory_transactions", 'String'>
    readonly quantity_change: FieldRef<"inventory_transactions", 'Int'>
    readonly related_order_id: FieldRef<"inventory_transactions", 'Int'>
    readonly related_return_id: FieldRef<"inventory_transactions", 'Int'>
    readonly created_at: FieldRef<"inventory_transactions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inventory_transactions findUnique
   */
  export type inventory_transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which inventory_transactions to fetch.
     */
    where: inventory_transactionsWhereUniqueInput
  }

  /**
   * inventory_transactions findUniqueOrThrow
   */
  export type inventory_transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which inventory_transactions to fetch.
     */
    where: inventory_transactionsWhereUniqueInput
  }

  /**
   * inventory_transactions findFirst
   */
  export type inventory_transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which inventory_transactions to fetch.
     */
    where?: inventory_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_transactions to fetch.
     */
    orderBy?: inventory_transactionsOrderByWithRelationInput | inventory_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventory_transactions.
     */
    cursor?: inventory_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventory_transactions.
     */
    distinct?: Inventory_transactionsScalarFieldEnum | Inventory_transactionsScalarFieldEnum[]
  }

  /**
   * inventory_transactions findFirstOrThrow
   */
  export type inventory_transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which inventory_transactions to fetch.
     */
    where?: inventory_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_transactions to fetch.
     */
    orderBy?: inventory_transactionsOrderByWithRelationInput | inventory_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inventory_transactions.
     */
    cursor?: inventory_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inventory_transactions.
     */
    distinct?: Inventory_transactionsScalarFieldEnum | Inventory_transactionsScalarFieldEnum[]
  }

  /**
   * inventory_transactions findMany
   */
  export type inventory_transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * Filter, which inventory_transactions to fetch.
     */
    where?: inventory_transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inventory_transactions to fetch.
     */
    orderBy?: inventory_transactionsOrderByWithRelationInput | inventory_transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inventory_transactions.
     */
    cursor?: inventory_transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inventory_transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inventory_transactions.
     */
    skip?: number
    distinct?: Inventory_transactionsScalarFieldEnum | Inventory_transactionsScalarFieldEnum[]
  }

  /**
   * inventory_transactions create
   */
  export type inventory_transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a inventory_transactions.
     */
    data: XOR<inventory_transactionsCreateInput, inventory_transactionsUncheckedCreateInput>
  }

  /**
   * inventory_transactions createMany
   */
  export type inventory_transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inventory_transactions.
     */
    data: inventory_transactionsCreateManyInput | inventory_transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inventory_transactions createManyAndReturn
   */
  export type inventory_transactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many inventory_transactions.
     */
    data: inventory_transactionsCreateManyInput | inventory_transactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * inventory_transactions update
   */
  export type inventory_transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a inventory_transactions.
     */
    data: XOR<inventory_transactionsUpdateInput, inventory_transactionsUncheckedUpdateInput>
    /**
     * Choose, which inventory_transactions to update.
     */
    where: inventory_transactionsWhereUniqueInput
  }

  /**
   * inventory_transactions updateMany
   */
  export type inventory_transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inventory_transactions.
     */
    data: XOR<inventory_transactionsUpdateManyMutationInput, inventory_transactionsUncheckedUpdateManyInput>
    /**
     * Filter which inventory_transactions to update
     */
    where?: inventory_transactionsWhereInput
  }

  /**
   * inventory_transactions upsert
   */
  export type inventory_transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the inventory_transactions to update in case it exists.
     */
    where: inventory_transactionsWhereUniqueInput
    /**
     * In case the inventory_transactions found by the `where` argument doesn't exist, create a new inventory_transactions with this data.
     */
    create: XOR<inventory_transactionsCreateInput, inventory_transactionsUncheckedCreateInput>
    /**
     * In case the inventory_transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inventory_transactionsUpdateInput, inventory_transactionsUncheckedUpdateInput>
  }

  /**
   * inventory_transactions delete
   */
  export type inventory_transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
    /**
     * Filter which inventory_transactions to delete.
     */
    where: inventory_transactionsWhereUniqueInput
  }

  /**
   * inventory_transactions deleteMany
   */
  export type inventory_transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inventory_transactions to delete
     */
    where?: inventory_transactionsWhereInput
  }

  /**
   * inventory_transactions.order
   */
  export type inventory_transactions$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
  }

  /**
   * inventory_transactions.returns
   */
  export type inventory_transactions$returnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the returns
     */
    select?: returnsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: returnsInclude<ExtArgs> | null
    where?: returnsWhereInput
  }

  /**
   * inventory_transactions without action
   */
  export type inventory_transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inventory_transactions
     */
    select?: inventory_transactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inventory_transactionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    created_at: 'created_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    customer_id: 'customer_id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    created_at: 'created_at'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    product_id: 'product_id',
    name: 'name',
    sku: 'sku',
    barcode: 'barcode',
    description: 'description',
    price: 'price',
    created_at: 'created_at'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    inventory_id: 'inventory_id',
    product_id: 'product_id',
    quantity: 'quantity',
    updated_at: 'updated_at'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    order_id: 'order_id',
    customer_id: 'customer_id',
    order_date: 'order_date',
    status: 'status',
    total_amount: 'total_amount'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const Order_itemsScalarFieldEnum: {
    order_item_id: 'order_item_id',
    order_id: 'order_id',
    product_id: 'product_id',
    quantity: 'quantity',
    unit_price: 'unit_price',
    subtotal: 'subtotal'
  };

  export type Order_itemsScalarFieldEnum = (typeof Order_itemsScalarFieldEnum)[keyof typeof Order_itemsScalarFieldEnum]


  export const Payment_methodsScalarFieldEnum: {
    payment_method_id: 'payment_method_id',
    method_name: 'method_name',
    description: 'description',
    created_at: 'created_at'
  };

  export type Payment_methodsScalarFieldEnum = (typeof Payment_methodsScalarFieldEnum)[keyof typeof Payment_methodsScalarFieldEnum]


  export const Order_paymentsScalarFieldEnum: {
    order_payment_id: 'order_payment_id',
    order_id: 'order_id',
    payment_method_id: 'payment_method_id',
    amount: 'amount',
    payment_date: 'payment_date',
    reference_no: 'reference_no',
    notes: 'notes'
  };

  export type Order_paymentsScalarFieldEnum = (typeof Order_paymentsScalarFieldEnum)[keyof typeof Order_paymentsScalarFieldEnum]


  export const ReturnsScalarFieldEnum: {
    return_id: 'return_id',
    order_id: 'order_id',
    return_date: 'return_date',
    status: 'status',
    refund_amount: 'refund_amount'
  };

  export type ReturnsScalarFieldEnum = (typeof ReturnsScalarFieldEnum)[keyof typeof ReturnsScalarFieldEnum]


  export const Return_itemsScalarFieldEnum: {
    return_item_id: 'return_item_id',
    return_id: 'return_id',
    product_id: 'product_id',
    quantity: 'quantity',
    refund_amount: 'refund_amount'
  };

  export type Return_itemsScalarFieldEnum = (typeof Return_itemsScalarFieldEnum)[keyof typeof Return_itemsScalarFieldEnum]


  export const Inventory_transactionsScalarFieldEnum: {
    transaction_id: 'transaction_id',
    product_id: 'product_id',
    change_type: 'change_type',
    quantity_change: 'quantity_change',
    related_order_id: 'related_order_id',
    related_return_id: 'related_return_id',
    created_at: 'created_at'
  };

  export type Inventory_transactionsScalarFieldEnum = (typeof Inventory_transactionsScalarFieldEnum)[keyof typeof Inventory_transactionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    role?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    role?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
  }, "user_id" | "email">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    created_at?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    role?: StringWithAggregatesFilter<"users"> | string
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type customersWhereInput = {
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    customer_id?: StringFilter<"customers"> | string
    name?: StringFilter<"customers"> | string
    email?: StringNullableFilter<"customers"> | string | null
    phone?: StringNullableFilter<"customers"> | string | null
    created_at?: DateTimeFilter<"customers"> | Date | string
    orders?: OrdersListRelationFilter
  }

  export type customersOrderByWithRelationInput = {
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    orders?: ordersOrderByRelationAggregateInput
  }

  export type customersWhereUniqueInput = Prisma.AtLeast<{
    customer_id?: string
    AND?: customersWhereInput | customersWhereInput[]
    OR?: customersWhereInput[]
    NOT?: customersWhereInput | customersWhereInput[]
    name?: StringFilter<"customers"> | string
    email?: StringNullableFilter<"customers"> | string | null
    phone?: StringNullableFilter<"customers"> | string | null
    created_at?: DateTimeFilter<"customers"> | Date | string
    orders?: OrdersListRelationFilter
  }, "customer_id">

  export type customersOrderByWithAggregationInput = {
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: customersCountOrderByAggregateInput
    _max?: customersMaxOrderByAggregateInput
    _min?: customersMinOrderByAggregateInput
  }

  export type customersScalarWhereWithAggregatesInput = {
    AND?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    OR?: customersScalarWhereWithAggregatesInput[]
    NOT?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[]
    customer_id?: StringWithAggregatesFilter<"customers"> | string
    name?: StringWithAggregatesFilter<"customers"> | string
    email?: StringNullableWithAggregatesFilter<"customers"> | string | null
    phone?: StringNullableWithAggregatesFilter<"customers"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"customers"> | Date | string
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    product_id?: StringFilter<"products"> | string
    name?: StringFilter<"products"> | string
    sku?: StringFilter<"products"> | string
    barcode?: StringNullableFilter<"products"> | string | null
    description?: StringNullableFilter<"products"> | string | null
    price?: DecimalFilter<"products"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"products"> | Date | string
    inventory?: XOR<InventoryNullableRelationFilter, inventoryWhereInput> | null
    order_items?: Order_itemsListRelationFilter
    inventory_transactions?: Inventory_transactionsListRelationFilter
    return_items?: Return_itemsListRelationFilter
  }

  export type productsOrderByWithRelationInput = {
    product_id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    inventory?: inventoryOrderByWithRelationInput
    order_items?: order_itemsOrderByRelationAggregateInput
    inventory_transactions?: inventory_transactionsOrderByRelationAggregateInput
    return_items?: return_itemsOrderByRelationAggregateInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    product_id?: string
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    name?: StringFilter<"products"> | string
    sku?: StringFilter<"products"> | string
    barcode?: StringNullableFilter<"products"> | string | null
    description?: StringNullableFilter<"products"> | string | null
    price?: DecimalFilter<"products"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFilter<"products"> | Date | string
    inventory?: XOR<InventoryNullableRelationFilter, inventoryWhereInput> | null
    order_items?: Order_itemsListRelationFilter
    inventory_transactions?: Inventory_transactionsListRelationFilter
    return_items?: Return_itemsListRelationFilter
  }, "product_id">

  export type productsOrderByWithAggregationInput = {
    product_id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    barcode?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    created_at?: SortOrder
    _count?: productsCountOrderByAggregateInput
    _avg?: productsAvgOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
    _sum?: productsSumOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    product_id?: StringWithAggregatesFilter<"products"> | string
    name?: StringWithAggregatesFilter<"products"> | string
    sku?: StringWithAggregatesFilter<"products"> | string
    barcode?: StringNullableWithAggregatesFilter<"products"> | string | null
    description?: StringNullableWithAggregatesFilter<"products"> | string | null
    price?: DecimalWithAggregatesFilter<"products"> | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeWithAggregatesFilter<"products"> | Date | string
  }

  export type inventoryWhereInput = {
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    inventory_id?: StringFilter<"inventory"> | string
    product_id?: StringFilter<"inventory"> | string
    quantity?: IntFilter<"inventory"> | number
    updated_at?: DateTimeFilter<"inventory"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }

  export type inventoryOrderByWithRelationInput = {
    inventory_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    updated_at?: SortOrder
    product?: productsOrderByWithRelationInput
  }

  export type inventoryWhereUniqueInput = Prisma.AtLeast<{
    inventory_id?: string
    product_id?: string
    AND?: inventoryWhereInput | inventoryWhereInput[]
    OR?: inventoryWhereInput[]
    NOT?: inventoryWhereInput | inventoryWhereInput[]
    quantity?: IntFilter<"inventory"> | number
    updated_at?: DateTimeFilter<"inventory"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }, "inventory_id" | "product_id">

  export type inventoryOrderByWithAggregationInput = {
    inventory_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    updated_at?: SortOrder
    _count?: inventoryCountOrderByAggregateInput
    _avg?: inventoryAvgOrderByAggregateInput
    _max?: inventoryMaxOrderByAggregateInput
    _min?: inventoryMinOrderByAggregateInput
    _sum?: inventorySumOrderByAggregateInput
  }

  export type inventoryScalarWhereWithAggregatesInput = {
    AND?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    OR?: inventoryScalarWhereWithAggregatesInput[]
    NOT?: inventoryScalarWhereWithAggregatesInput | inventoryScalarWhereWithAggregatesInput[]
    inventory_id?: StringWithAggregatesFilter<"inventory"> | string
    product_id?: StringWithAggregatesFilter<"inventory"> | string
    quantity?: IntWithAggregatesFilter<"inventory"> | number
    updated_at?: DateTimeWithAggregatesFilter<"inventory"> | Date | string
  }

  export type ordersWhereInput = {
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    order_id?: IntFilter<"orders"> | number
    customer_id?: StringNullableFilter<"orders"> | string | null
    order_date?: DateTimeFilter<"orders"> | Date | string
    status?: StringFilter<"orders"> | string
    total_amount?: DecimalFilter<"orders"> | Decimal | DecimalJsLike | number | string
    customer?: XOR<CustomersNullableRelationFilter, customersWhereInput> | null
    order_items?: Order_itemsListRelationFilter
    order_payments?: Order_paymentsListRelationFilter
    returns?: XOR<ReturnsNullableRelationFilter, returnsWhereInput> | null
    inventory_transactions?: Inventory_transactionsListRelationFilter
  }

  export type ordersOrderByWithRelationInput = {
    order_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    order_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    customer?: customersOrderByWithRelationInput
    order_items?: order_itemsOrderByRelationAggregateInput
    order_payments?: order_paymentsOrderByRelationAggregateInput
    returns?: returnsOrderByWithRelationInput
    inventory_transactions?: inventory_transactionsOrderByRelationAggregateInput
  }

  export type ordersWhereUniqueInput = Prisma.AtLeast<{
    order_id?: number
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    customer_id?: StringNullableFilter<"orders"> | string | null
    order_date?: DateTimeFilter<"orders"> | Date | string
    status?: StringFilter<"orders"> | string
    total_amount?: DecimalFilter<"orders"> | Decimal | DecimalJsLike | number | string
    customer?: XOR<CustomersNullableRelationFilter, customersWhereInput> | null
    order_items?: Order_itemsListRelationFilter
    order_payments?: Order_paymentsListRelationFilter
    returns?: XOR<ReturnsNullableRelationFilter, returnsWhereInput> | null
    inventory_transactions?: Inventory_transactionsListRelationFilter
  }, "order_id">

  export type ordersOrderByWithAggregationInput = {
    order_id?: SortOrder
    customer_id?: SortOrderInput | SortOrder
    order_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    _count?: ordersCountOrderByAggregateInput
    _avg?: ordersAvgOrderByAggregateInput
    _max?: ordersMaxOrderByAggregateInput
    _min?: ordersMinOrderByAggregateInput
    _sum?: ordersSumOrderByAggregateInput
  }

  export type ordersScalarWhereWithAggregatesInput = {
    AND?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    OR?: ordersScalarWhereWithAggregatesInput[]
    NOT?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    order_id?: IntWithAggregatesFilter<"orders"> | number
    customer_id?: StringNullableWithAggregatesFilter<"orders"> | string | null
    order_date?: DateTimeWithAggregatesFilter<"orders"> | Date | string
    status?: StringWithAggregatesFilter<"orders"> | string
    total_amount?: DecimalWithAggregatesFilter<"orders"> | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsWhereInput = {
    AND?: order_itemsWhereInput | order_itemsWhereInput[]
    OR?: order_itemsWhereInput[]
    NOT?: order_itemsWhereInput | order_itemsWhereInput[]
    order_item_id?: StringFilter<"order_items"> | string
    order_id?: IntFilter<"order_items"> | number
    product_id?: StringFilter<"order_items"> | string
    quantity?: IntFilter<"order_items"> | number
    unit_price?: DecimalFilter<"order_items"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"order_items"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrdersRelationFilter, ordersWhereInput>
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }

  export type order_itemsOrderByWithRelationInput = {
    order_item_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    subtotal?: SortOrder
    order?: ordersOrderByWithRelationInput
    product?: productsOrderByWithRelationInput
  }

  export type order_itemsWhereUniqueInput = Prisma.AtLeast<{
    order_item_id?: string
    AND?: order_itemsWhereInput | order_itemsWhereInput[]
    OR?: order_itemsWhereInput[]
    NOT?: order_itemsWhereInput | order_itemsWhereInput[]
    order_id?: IntFilter<"order_items"> | number
    product_id?: StringFilter<"order_items"> | string
    quantity?: IntFilter<"order_items"> | number
    unit_price?: DecimalFilter<"order_items"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"order_items"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrdersRelationFilter, ordersWhereInput>
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }, "order_item_id">

  export type order_itemsOrderByWithAggregationInput = {
    order_item_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    subtotal?: SortOrder
    _count?: order_itemsCountOrderByAggregateInput
    _avg?: order_itemsAvgOrderByAggregateInput
    _max?: order_itemsMaxOrderByAggregateInput
    _min?: order_itemsMinOrderByAggregateInput
    _sum?: order_itemsSumOrderByAggregateInput
  }

  export type order_itemsScalarWhereWithAggregatesInput = {
    AND?: order_itemsScalarWhereWithAggregatesInput | order_itemsScalarWhereWithAggregatesInput[]
    OR?: order_itemsScalarWhereWithAggregatesInput[]
    NOT?: order_itemsScalarWhereWithAggregatesInput | order_itemsScalarWhereWithAggregatesInput[]
    order_item_id?: StringWithAggregatesFilter<"order_items"> | string
    order_id?: IntWithAggregatesFilter<"order_items"> | number
    product_id?: StringWithAggregatesFilter<"order_items"> | string
    quantity?: IntWithAggregatesFilter<"order_items"> | number
    unit_price?: DecimalWithAggregatesFilter<"order_items"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"order_items"> | Decimal | DecimalJsLike | number | string
  }

  export type payment_methodsWhereInput = {
    AND?: payment_methodsWhereInput | payment_methodsWhereInput[]
    OR?: payment_methodsWhereInput[]
    NOT?: payment_methodsWhereInput | payment_methodsWhereInput[]
    payment_method_id?: StringFilter<"payment_methods"> | string
    method_name?: StringFilter<"payment_methods"> | string
    description?: StringNullableFilter<"payment_methods"> | string | null
    created_at?: DateTimeFilter<"payment_methods"> | Date | string
    order_payments?: Order_paymentsListRelationFilter
  }

  export type payment_methodsOrderByWithRelationInput = {
    payment_method_id?: SortOrder
    method_name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    order_payments?: order_paymentsOrderByRelationAggregateInput
  }

  export type payment_methodsWhereUniqueInput = Prisma.AtLeast<{
    payment_method_id?: string
    AND?: payment_methodsWhereInput | payment_methodsWhereInput[]
    OR?: payment_methodsWhereInput[]
    NOT?: payment_methodsWhereInput | payment_methodsWhereInput[]
    method_name?: StringFilter<"payment_methods"> | string
    description?: StringNullableFilter<"payment_methods"> | string | null
    created_at?: DateTimeFilter<"payment_methods"> | Date | string
    order_payments?: Order_paymentsListRelationFilter
  }, "payment_method_id">

  export type payment_methodsOrderByWithAggregationInput = {
    payment_method_id?: SortOrder
    method_name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: payment_methodsCountOrderByAggregateInput
    _max?: payment_methodsMaxOrderByAggregateInput
    _min?: payment_methodsMinOrderByAggregateInput
  }

  export type payment_methodsScalarWhereWithAggregatesInput = {
    AND?: payment_methodsScalarWhereWithAggregatesInput | payment_methodsScalarWhereWithAggregatesInput[]
    OR?: payment_methodsScalarWhereWithAggregatesInput[]
    NOT?: payment_methodsScalarWhereWithAggregatesInput | payment_methodsScalarWhereWithAggregatesInput[]
    payment_method_id?: StringWithAggregatesFilter<"payment_methods"> | string
    method_name?: StringWithAggregatesFilter<"payment_methods"> | string
    description?: StringNullableWithAggregatesFilter<"payment_methods"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"payment_methods"> | Date | string
  }

  export type order_paymentsWhereInput = {
    AND?: order_paymentsWhereInput | order_paymentsWhereInput[]
    OR?: order_paymentsWhereInput[]
    NOT?: order_paymentsWhereInput | order_paymentsWhereInput[]
    order_payment_id?: StringFilter<"order_payments"> | string
    order_id?: IntFilter<"order_payments"> | number
    payment_method_id?: StringFilter<"order_payments"> | string
    amount?: DecimalFilter<"order_payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"order_payments"> | Date | string
    reference_no?: StringNullableFilter<"order_payments"> | string | null
    notes?: StringNullableFilter<"order_payments"> | string | null
    order?: XOR<OrdersRelationFilter, ordersWhereInput>
    payment_methods?: XOR<Payment_methodsRelationFilter, payment_methodsWhereInput>
  }

  export type order_paymentsOrderByWithRelationInput = {
    order_payment_id?: SortOrder
    order_id?: SortOrder
    payment_method_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    order?: ordersOrderByWithRelationInput
    payment_methods?: payment_methodsOrderByWithRelationInput
  }

  export type order_paymentsWhereUniqueInput = Prisma.AtLeast<{
    order_payment_id?: string
    AND?: order_paymentsWhereInput | order_paymentsWhereInput[]
    OR?: order_paymentsWhereInput[]
    NOT?: order_paymentsWhereInput | order_paymentsWhereInput[]
    order_id?: IntFilter<"order_payments"> | number
    payment_method_id?: StringFilter<"order_payments"> | string
    amount?: DecimalFilter<"order_payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"order_payments"> | Date | string
    reference_no?: StringNullableFilter<"order_payments"> | string | null
    notes?: StringNullableFilter<"order_payments"> | string | null
    order?: XOR<OrdersRelationFilter, ordersWhereInput>
    payment_methods?: XOR<Payment_methodsRelationFilter, payment_methodsWhereInput>
  }, "order_payment_id">

  export type order_paymentsOrderByWithAggregationInput = {
    order_payment_id?: SortOrder
    order_id?: SortOrder
    payment_method_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: order_paymentsCountOrderByAggregateInput
    _avg?: order_paymentsAvgOrderByAggregateInput
    _max?: order_paymentsMaxOrderByAggregateInput
    _min?: order_paymentsMinOrderByAggregateInput
    _sum?: order_paymentsSumOrderByAggregateInput
  }

  export type order_paymentsScalarWhereWithAggregatesInput = {
    AND?: order_paymentsScalarWhereWithAggregatesInput | order_paymentsScalarWhereWithAggregatesInput[]
    OR?: order_paymentsScalarWhereWithAggregatesInput[]
    NOT?: order_paymentsScalarWhereWithAggregatesInput | order_paymentsScalarWhereWithAggregatesInput[]
    order_payment_id?: StringWithAggregatesFilter<"order_payments"> | string
    order_id?: IntWithAggregatesFilter<"order_payments"> | number
    payment_method_id?: StringWithAggregatesFilter<"order_payments"> | string
    amount?: DecimalWithAggregatesFilter<"order_payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeWithAggregatesFilter<"order_payments"> | Date | string
    reference_no?: StringNullableWithAggregatesFilter<"order_payments"> | string | null
    notes?: StringNullableWithAggregatesFilter<"order_payments"> | string | null
  }

  export type returnsWhereInput = {
    AND?: returnsWhereInput | returnsWhereInput[]
    OR?: returnsWhereInput[]
    NOT?: returnsWhereInput | returnsWhereInput[]
    return_id?: IntFilter<"returns"> | number
    order_id?: IntNullableFilter<"returns"> | number | null
    return_date?: DateTimeFilter<"returns"> | Date | string
    status?: StringFilter<"returns"> | string
    refund_amount?: DecimalFilter<"returns"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrdersNullableRelationFilter, ordersWhereInput> | null
    return_items?: Return_itemsListRelationFilter
    inventory_transactions?: Inventory_transactionsListRelationFilter
  }

  export type returnsOrderByWithRelationInput = {
    return_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    return_date?: SortOrder
    status?: SortOrder
    refund_amount?: SortOrder
    order?: ordersOrderByWithRelationInput
    return_items?: return_itemsOrderByRelationAggregateInput
    inventory_transactions?: inventory_transactionsOrderByRelationAggregateInput
  }

  export type returnsWhereUniqueInput = Prisma.AtLeast<{
    return_id?: number
    order_id?: number
    AND?: returnsWhereInput | returnsWhereInput[]
    OR?: returnsWhereInput[]
    NOT?: returnsWhereInput | returnsWhereInput[]
    return_date?: DateTimeFilter<"returns"> | Date | string
    status?: StringFilter<"returns"> | string
    refund_amount?: DecimalFilter<"returns"> | Decimal | DecimalJsLike | number | string
    order?: XOR<OrdersNullableRelationFilter, ordersWhereInput> | null
    return_items?: Return_itemsListRelationFilter
    inventory_transactions?: Inventory_transactionsListRelationFilter
  }, "return_id" | "order_id">

  export type returnsOrderByWithAggregationInput = {
    return_id?: SortOrder
    order_id?: SortOrderInput | SortOrder
    return_date?: SortOrder
    status?: SortOrder
    refund_amount?: SortOrder
    _count?: returnsCountOrderByAggregateInput
    _avg?: returnsAvgOrderByAggregateInput
    _max?: returnsMaxOrderByAggregateInput
    _min?: returnsMinOrderByAggregateInput
    _sum?: returnsSumOrderByAggregateInput
  }

  export type returnsScalarWhereWithAggregatesInput = {
    AND?: returnsScalarWhereWithAggregatesInput | returnsScalarWhereWithAggregatesInput[]
    OR?: returnsScalarWhereWithAggregatesInput[]
    NOT?: returnsScalarWhereWithAggregatesInput | returnsScalarWhereWithAggregatesInput[]
    return_id?: IntWithAggregatesFilter<"returns"> | number
    order_id?: IntNullableWithAggregatesFilter<"returns"> | number | null
    return_date?: DateTimeWithAggregatesFilter<"returns"> | Date | string
    status?: StringWithAggregatesFilter<"returns"> | string
    refund_amount?: DecimalWithAggregatesFilter<"returns"> | Decimal | DecimalJsLike | number | string
  }

  export type return_itemsWhereInput = {
    AND?: return_itemsWhereInput | return_itemsWhereInput[]
    OR?: return_itemsWhereInput[]
    NOT?: return_itemsWhereInput | return_itemsWhereInput[]
    return_item_id?: StringFilter<"return_items"> | string
    return_id?: IntFilter<"return_items"> | number
    product_id?: StringFilter<"return_items"> | string
    quantity?: IntFilter<"return_items"> | number
    refund_amount?: DecimalFilter<"return_items"> | Decimal | DecimalJsLike | number | string
    returns?: XOR<ReturnsRelationFilter, returnsWhereInput>
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }

  export type return_itemsOrderByWithRelationInput = {
    return_item_id?: SortOrder
    return_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    refund_amount?: SortOrder
    returns?: returnsOrderByWithRelationInput
    product?: productsOrderByWithRelationInput
  }

  export type return_itemsWhereUniqueInput = Prisma.AtLeast<{
    return_item_id?: string
    AND?: return_itemsWhereInput | return_itemsWhereInput[]
    OR?: return_itemsWhereInput[]
    NOT?: return_itemsWhereInput | return_itemsWhereInput[]
    return_id?: IntFilter<"return_items"> | number
    product_id?: StringFilter<"return_items"> | string
    quantity?: IntFilter<"return_items"> | number
    refund_amount?: DecimalFilter<"return_items"> | Decimal | DecimalJsLike | number | string
    returns?: XOR<ReturnsRelationFilter, returnsWhereInput>
    product?: XOR<ProductsRelationFilter, productsWhereInput>
  }, "return_item_id">

  export type return_itemsOrderByWithAggregationInput = {
    return_item_id?: SortOrder
    return_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    refund_amount?: SortOrder
    _count?: return_itemsCountOrderByAggregateInput
    _avg?: return_itemsAvgOrderByAggregateInput
    _max?: return_itemsMaxOrderByAggregateInput
    _min?: return_itemsMinOrderByAggregateInput
    _sum?: return_itemsSumOrderByAggregateInput
  }

  export type return_itemsScalarWhereWithAggregatesInput = {
    AND?: return_itemsScalarWhereWithAggregatesInput | return_itemsScalarWhereWithAggregatesInput[]
    OR?: return_itemsScalarWhereWithAggregatesInput[]
    NOT?: return_itemsScalarWhereWithAggregatesInput | return_itemsScalarWhereWithAggregatesInput[]
    return_item_id?: StringWithAggregatesFilter<"return_items"> | string
    return_id?: IntWithAggregatesFilter<"return_items"> | number
    product_id?: StringWithAggregatesFilter<"return_items"> | string
    quantity?: IntWithAggregatesFilter<"return_items"> | number
    refund_amount?: DecimalWithAggregatesFilter<"return_items"> | Decimal | DecimalJsLike | number | string
  }

  export type inventory_transactionsWhereInput = {
    AND?: inventory_transactionsWhereInput | inventory_transactionsWhereInput[]
    OR?: inventory_transactionsWhereInput[]
    NOT?: inventory_transactionsWhereInput | inventory_transactionsWhereInput[]
    transaction_id?: StringFilter<"inventory_transactions"> | string
    product_id?: StringFilter<"inventory_transactions"> | string
    change_type?: StringFilter<"inventory_transactions"> | string
    quantity_change?: IntFilter<"inventory_transactions"> | number
    related_order_id?: IntNullableFilter<"inventory_transactions"> | number | null
    related_return_id?: IntNullableFilter<"inventory_transactions"> | number | null
    created_at?: DateTimeFilter<"inventory_transactions"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
    order?: XOR<OrdersNullableRelationFilter, ordersWhereInput> | null
    returns?: XOR<ReturnsNullableRelationFilter, returnsWhereInput> | null
  }

  export type inventory_transactionsOrderByWithRelationInput = {
    transaction_id?: SortOrder
    product_id?: SortOrder
    change_type?: SortOrder
    quantity_change?: SortOrder
    related_order_id?: SortOrderInput | SortOrder
    related_return_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    product?: productsOrderByWithRelationInput
    order?: ordersOrderByWithRelationInput
    returns?: returnsOrderByWithRelationInput
  }

  export type inventory_transactionsWhereUniqueInput = Prisma.AtLeast<{
    transaction_id?: string
    AND?: inventory_transactionsWhereInput | inventory_transactionsWhereInput[]
    OR?: inventory_transactionsWhereInput[]
    NOT?: inventory_transactionsWhereInput | inventory_transactionsWhereInput[]
    product_id?: StringFilter<"inventory_transactions"> | string
    change_type?: StringFilter<"inventory_transactions"> | string
    quantity_change?: IntFilter<"inventory_transactions"> | number
    related_order_id?: IntNullableFilter<"inventory_transactions"> | number | null
    related_return_id?: IntNullableFilter<"inventory_transactions"> | number | null
    created_at?: DateTimeFilter<"inventory_transactions"> | Date | string
    product?: XOR<ProductsRelationFilter, productsWhereInput>
    order?: XOR<OrdersNullableRelationFilter, ordersWhereInput> | null
    returns?: XOR<ReturnsNullableRelationFilter, returnsWhereInput> | null
  }, "transaction_id">

  export type inventory_transactionsOrderByWithAggregationInput = {
    transaction_id?: SortOrder
    product_id?: SortOrder
    change_type?: SortOrder
    quantity_change?: SortOrder
    related_order_id?: SortOrderInput | SortOrder
    related_return_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: inventory_transactionsCountOrderByAggregateInput
    _avg?: inventory_transactionsAvgOrderByAggregateInput
    _max?: inventory_transactionsMaxOrderByAggregateInput
    _min?: inventory_transactionsMinOrderByAggregateInput
    _sum?: inventory_transactionsSumOrderByAggregateInput
  }

  export type inventory_transactionsScalarWhereWithAggregatesInput = {
    AND?: inventory_transactionsScalarWhereWithAggregatesInput | inventory_transactionsScalarWhereWithAggregatesInput[]
    OR?: inventory_transactionsScalarWhereWithAggregatesInput[]
    NOT?: inventory_transactionsScalarWhereWithAggregatesInput | inventory_transactionsScalarWhereWithAggregatesInput[]
    transaction_id?: StringWithAggregatesFilter<"inventory_transactions"> | string
    product_id?: StringWithAggregatesFilter<"inventory_transactions"> | string
    change_type?: StringWithAggregatesFilter<"inventory_transactions"> | string
    quantity_change?: IntWithAggregatesFilter<"inventory_transactions"> | number
    related_order_id?: IntNullableWithAggregatesFilter<"inventory_transactions"> | number | null
    related_return_id?: IntNullableWithAggregatesFilter<"inventory_transactions"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"inventory_transactions"> | Date | string
  }

  export type usersCreateInput = {
    user_id?: string
    email: string
    password: string
    name?: string | null
    role?: string
    created_at?: Date | string
  }

  export type usersUncheckedCreateInput = {
    user_id?: string
    email: string
    password: string
    name?: string | null
    role?: string
    created_at?: Date | string
  }

  export type usersUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateManyInput = {
    user_id?: string
    email: string
    password: string
    name?: string | null
    role?: string
    created_at?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customersCreateInput = {
    customer_id?: string
    name: string
    email?: string | null
    phone?: string | null
    created_at?: Date | string
    orders?: ordersCreateNestedManyWithoutCustomerInput
  }

  export type customersUncheckedCreateInput = {
    customer_id?: string
    name: string
    email?: string | null
    phone?: string | null
    created_at?: Date | string
    orders?: ordersUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customersUpdateInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUpdateManyWithoutCustomerNestedInput
  }

  export type customersUncheckedUpdateInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: ordersUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customersCreateManyInput = {
    customer_id?: string
    name: string
    email?: string | null
    phone?: string | null
    created_at?: Date | string
  }

  export type customersUpdateManyMutationInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customersUncheckedUpdateManyInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsCreateInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryCreateNestedOneWithoutProductInput
    order_items?: order_itemsCreateNestedManyWithoutProductInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutProductInput
    return_items?: return_itemsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryUncheckedCreateNestedOneWithoutProductInput
    order_items?: order_itemsUncheckedCreateNestedManyWithoutProductInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutProductInput
    return_items?: return_itemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsUpdateInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUpdateOneWithoutProductNestedInput
    order_items?: order_itemsUpdateManyWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUncheckedUpdateOneWithoutProductNestedInput
    order_items?: order_itemsUncheckedUpdateManyWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productsCreateManyInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
  }

  export type productsUpdateManyMutationInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsUncheckedUpdateManyInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventoryCreateInput = {
    inventory_id?: string
    quantity: number
    updated_at?: Date | string
    product: productsCreateNestedOneWithoutInventoryInput
  }

  export type inventoryUncheckedCreateInput = {
    inventory_id?: string
    product_id: string
    quantity: number
    updated_at?: Date | string
  }

  export type inventoryUpdateInput = {
    inventory_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type inventoryUncheckedUpdateInput = {
    inventory_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventoryCreateManyInput = {
    inventory_id?: string
    product_id: string
    quantity: number
    updated_at?: Date | string
  }

  export type inventoryUpdateManyMutationInput = {
    inventory_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventoryUncheckedUpdateManyInput = {
    inventory_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersCreateInput = {
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    customer?: customersCreateNestedOneWithoutOrdersInput
    order_items?: order_itemsCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsCreateNestedManyWithoutOrderInput
    returns?: returnsCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutOrderInput
  }

  export type ordersUncheckedCreateInput = {
    order_id?: number
    customer_id?: string | null
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsUncheckedCreateNestedManyWithoutOrderInput
    returns?: returnsUncheckedCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ordersUpdateInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: customersUpdateOneWithoutOrdersNestedInput
    order_items?: order_itemsUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUpdateManyWithoutOrderNestedInput
    returns?: returnsUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUncheckedUpdateManyWithoutOrderNestedInput
    returns?: returnsUncheckedUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ordersCreateManyInput = {
    order_id?: number
    customer_id?: string | null
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
  }

  export type ordersUpdateManyMutationInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ordersUncheckedUpdateManyInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsCreateInput = {
    order_item_id?: string
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    order: ordersCreateNestedOneWithoutOrder_itemsInput
    product: productsCreateNestedOneWithoutOrder_itemsInput
  }

  export type order_itemsUncheckedCreateInput = {
    order_item_id?: string
    order_id: number
    product_id: string
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type order_itemsUpdateInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: ordersUpdateOneRequiredWithoutOrder_itemsNestedInput
    product?: productsUpdateOneRequiredWithoutOrder_itemsNestedInput
  }

  export type order_itemsUncheckedUpdateInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsCreateManyInput = {
    order_item_id?: string
    order_id: number
    product_id: string
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type order_itemsUpdateManyMutationInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsUncheckedUpdateManyInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type payment_methodsCreateInput = {
    payment_method_id?: string
    method_name: string
    description?: string | null
    created_at?: Date | string
    order_payments?: order_paymentsCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsUncheckedCreateInput = {
    payment_method_id?: string
    method_name: string
    description?: string | null
    created_at?: Date | string
    order_payments?: order_paymentsUncheckedCreateNestedManyWithoutPayment_methodsInput
  }

  export type payment_methodsUpdateInput = {
    payment_method_id?: StringFieldUpdateOperationsInput | string
    method_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_payments?: order_paymentsUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsUncheckedUpdateInput = {
    payment_method_id?: StringFieldUpdateOperationsInput | string
    method_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_payments?: order_paymentsUncheckedUpdateManyWithoutPayment_methodsNestedInput
  }

  export type payment_methodsCreateManyInput = {
    payment_method_id?: string
    method_name: string
    description?: string | null
    created_at?: Date | string
  }

  export type payment_methodsUpdateManyMutationInput = {
    payment_method_id?: StringFieldUpdateOperationsInput | string
    method_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_methodsUncheckedUpdateManyInput = {
    payment_method_id?: StringFieldUpdateOperationsInput | string
    method_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_paymentsCreateInput = {
    order_payment_id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
    order: ordersCreateNestedOneWithoutOrder_paymentsInput
    payment_methods: payment_methodsCreateNestedOneWithoutOrder_paymentsInput
  }

  export type order_paymentsUncheckedCreateInput = {
    order_payment_id?: string
    order_id: number
    payment_method_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
  }

  export type order_paymentsUpdateInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: ordersUpdateOneRequiredWithoutOrder_paymentsNestedInput
    payment_methods?: payment_methodsUpdateOneRequiredWithoutOrder_paymentsNestedInput
  }

  export type order_paymentsUncheckedUpdateInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    payment_method_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_paymentsCreateManyInput = {
    order_payment_id?: string
    order_id: number
    payment_method_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
  }

  export type order_paymentsUpdateManyMutationInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_paymentsUncheckedUpdateManyInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    payment_method_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type returnsCreateInput = {
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    order?: ordersCreateNestedOneWithoutReturnsInput
    return_items?: return_itemsCreateNestedManyWithoutReturnsInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutReturnsInput
  }

  export type returnsUncheckedCreateInput = {
    return_id?: number
    order_id?: number | null
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    return_items?: return_itemsUncheckedCreateNestedManyWithoutReturnsInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutReturnsInput
  }

  export type returnsUpdateInput = {
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: ordersUpdateOneWithoutReturnsNestedInput
    return_items?: return_itemsUpdateManyWithoutReturnsNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutReturnsNestedInput
  }

  export type returnsUncheckedUpdateInput = {
    return_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_items?: return_itemsUncheckedUpdateManyWithoutReturnsNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutReturnsNestedInput
  }

  export type returnsCreateManyInput = {
    return_id?: number
    order_id?: number | null
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
  }

  export type returnsUpdateManyMutationInput = {
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type returnsUncheckedUpdateManyInput = {
    return_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type return_itemsCreateInput = {
    return_item_id?: string
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
    returns: returnsCreateNestedOneWithoutReturn_itemsInput
    product: productsCreateNestedOneWithoutReturn_itemsInput
  }

  export type return_itemsUncheckedCreateInput = {
    return_item_id?: string
    return_id: number
    product_id: string
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
  }

  export type return_itemsUpdateInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    returns?: returnsUpdateOneRequiredWithoutReturn_itemsNestedInput
    product?: productsUpdateOneRequiredWithoutReturn_itemsNestedInput
  }

  export type return_itemsUncheckedUpdateInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    return_id?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type return_itemsCreateManyInput = {
    return_item_id?: string
    return_id: number
    product_id: string
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
  }

  export type return_itemsUpdateManyMutationInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type return_itemsUncheckedUpdateManyInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    return_id?: IntFieldUpdateOperationsInput | number
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type inventory_transactionsCreateInput = {
    transaction_id?: string
    change_type: string
    quantity_change: number
    created_at?: Date | string
    product: productsCreateNestedOneWithoutInventory_transactionsInput
    order?: ordersCreateNestedOneWithoutInventory_transactionsInput
    returns?: returnsCreateNestedOneWithoutInventory_transactionsInput
  }

  export type inventory_transactionsUncheckedCreateInput = {
    transaction_id?: string
    product_id: string
    change_type: string
    quantity_change: number
    related_order_id?: number | null
    related_return_id?: number | null
    created_at?: Date | string
  }

  export type inventory_transactionsUpdateInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneRequiredWithoutInventory_transactionsNestedInput
    order?: ordersUpdateOneWithoutInventory_transactionsNestedInput
    returns?: returnsUpdateOneWithoutInventory_transactionsNestedInput
  }

  export type inventory_transactionsUncheckedUpdateInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    related_return_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_transactionsCreateManyInput = {
    transaction_id?: string
    product_id: string
    change_type: string
    quantity_change: number
    related_order_id?: number | null
    related_return_id?: number | null
    created_at?: Date | string
  }

  export type inventory_transactionsUpdateManyMutationInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_transactionsUncheckedUpdateManyInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    related_return_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OrdersListRelationFilter = {
    every?: ordersWhereInput
    some?: ordersWhereInput
    none?: ordersWhereInput
  }

  export type ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customersCountOrderByAggregateInput = {
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type customersMaxOrderByAggregateInput = {
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type customersMinOrderByAggregateInput = {
    customer_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type InventoryNullableRelationFilter = {
    is?: inventoryWhereInput | null
    isNot?: inventoryWhereInput | null
  }

  export type Order_itemsListRelationFilter = {
    every?: order_itemsWhereInput
    some?: order_itemsWhereInput
    none?: order_itemsWhereInput
  }

  export type Inventory_transactionsListRelationFilter = {
    every?: inventory_transactionsWhereInput
    some?: inventory_transactionsWhereInput
    none?: inventory_transactionsWhereInput
  }

  export type Return_itemsListRelationFilter = {
    every?: return_itemsWhereInput
    some?: return_itemsWhereInput
    none?: return_itemsWhereInput
  }

  export type order_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inventory_transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type return_itemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type productsCountOrderByAggregateInput = {
    product_id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
  }

  export type productsAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    product_id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    product_id?: SortOrder
    name?: SortOrder
    sku?: SortOrder
    barcode?: SortOrder
    description?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
  }

  export type productsSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductsRelationFilter = {
    is?: productsWhereInput
    isNot?: productsWhereInput
  }

  export type inventoryCountOrderByAggregateInput = {
    inventory_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    updated_at?: SortOrder
  }

  export type inventoryAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type inventoryMaxOrderByAggregateInput = {
    inventory_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    updated_at?: SortOrder
  }

  export type inventoryMinOrderByAggregateInput = {
    inventory_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    updated_at?: SortOrder
  }

  export type inventorySumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CustomersNullableRelationFilter = {
    is?: customersWhereInput | null
    isNot?: customersWhereInput | null
  }

  export type Order_paymentsListRelationFilter = {
    every?: order_paymentsWhereInput
    some?: order_paymentsWhereInput
    none?: order_paymentsWhereInput
  }

  export type ReturnsNullableRelationFilter = {
    is?: returnsWhereInput | null
    isNot?: returnsWhereInput | null
  }

  export type order_paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ordersCountOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    order_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
  }

  export type ordersAvgOrderByAggregateInput = {
    order_id?: SortOrder
    total_amount?: SortOrder
  }

  export type ordersMaxOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    order_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
  }

  export type ordersMinOrderByAggregateInput = {
    order_id?: SortOrder
    customer_id?: SortOrder
    order_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
  }

  export type ordersSumOrderByAggregateInput = {
    order_id?: SortOrder
    total_amount?: SortOrder
  }

  export type OrdersRelationFilter = {
    is?: ordersWhereInput
    isNot?: ordersWhereInput
  }

  export type order_itemsCountOrderByAggregateInput = {
    order_item_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    subtotal?: SortOrder
  }

  export type order_itemsAvgOrderByAggregateInput = {
    order_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    subtotal?: SortOrder
  }

  export type order_itemsMaxOrderByAggregateInput = {
    order_item_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    subtotal?: SortOrder
  }

  export type order_itemsMinOrderByAggregateInput = {
    order_item_id?: SortOrder
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    subtotal?: SortOrder
  }

  export type order_itemsSumOrderByAggregateInput = {
    order_id?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    subtotal?: SortOrder
  }

  export type payment_methodsCountOrderByAggregateInput = {
    payment_method_id?: SortOrder
    method_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type payment_methodsMaxOrderByAggregateInput = {
    payment_method_id?: SortOrder
    method_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type payment_methodsMinOrderByAggregateInput = {
    payment_method_id?: SortOrder
    method_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type Payment_methodsRelationFilter = {
    is?: payment_methodsWhereInput
    isNot?: payment_methodsWhereInput
  }

  export type order_paymentsCountOrderByAggregateInput = {
    order_payment_id?: SortOrder
    order_id?: SortOrder
    payment_method_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
  }

  export type order_paymentsAvgOrderByAggregateInput = {
    order_id?: SortOrder
    amount?: SortOrder
  }

  export type order_paymentsMaxOrderByAggregateInput = {
    order_payment_id?: SortOrder
    order_id?: SortOrder
    payment_method_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
  }

  export type order_paymentsMinOrderByAggregateInput = {
    order_payment_id?: SortOrder
    order_id?: SortOrder
    payment_method_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
  }

  export type order_paymentsSumOrderByAggregateInput = {
    order_id?: SortOrder
    amount?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OrdersNullableRelationFilter = {
    is?: ordersWhereInput | null
    isNot?: ordersWhereInput | null
  }

  export type returnsCountOrderByAggregateInput = {
    return_id?: SortOrder
    order_id?: SortOrder
    return_date?: SortOrder
    status?: SortOrder
    refund_amount?: SortOrder
  }

  export type returnsAvgOrderByAggregateInput = {
    return_id?: SortOrder
    order_id?: SortOrder
    refund_amount?: SortOrder
  }

  export type returnsMaxOrderByAggregateInput = {
    return_id?: SortOrder
    order_id?: SortOrder
    return_date?: SortOrder
    status?: SortOrder
    refund_amount?: SortOrder
  }

  export type returnsMinOrderByAggregateInput = {
    return_id?: SortOrder
    order_id?: SortOrder
    return_date?: SortOrder
    status?: SortOrder
    refund_amount?: SortOrder
  }

  export type returnsSumOrderByAggregateInput = {
    return_id?: SortOrder
    order_id?: SortOrder
    refund_amount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ReturnsRelationFilter = {
    is?: returnsWhereInput
    isNot?: returnsWhereInput
  }

  export type return_itemsCountOrderByAggregateInput = {
    return_item_id?: SortOrder
    return_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    refund_amount?: SortOrder
  }

  export type return_itemsAvgOrderByAggregateInput = {
    return_id?: SortOrder
    quantity?: SortOrder
    refund_amount?: SortOrder
  }

  export type return_itemsMaxOrderByAggregateInput = {
    return_item_id?: SortOrder
    return_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    refund_amount?: SortOrder
  }

  export type return_itemsMinOrderByAggregateInput = {
    return_item_id?: SortOrder
    return_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    refund_amount?: SortOrder
  }

  export type return_itemsSumOrderByAggregateInput = {
    return_id?: SortOrder
    quantity?: SortOrder
    refund_amount?: SortOrder
  }

  export type inventory_transactionsCountOrderByAggregateInput = {
    transaction_id?: SortOrder
    product_id?: SortOrder
    change_type?: SortOrder
    quantity_change?: SortOrder
    related_order_id?: SortOrder
    related_return_id?: SortOrder
    created_at?: SortOrder
  }

  export type inventory_transactionsAvgOrderByAggregateInput = {
    quantity_change?: SortOrder
    related_order_id?: SortOrder
    related_return_id?: SortOrder
  }

  export type inventory_transactionsMaxOrderByAggregateInput = {
    transaction_id?: SortOrder
    product_id?: SortOrder
    change_type?: SortOrder
    quantity_change?: SortOrder
    related_order_id?: SortOrder
    related_return_id?: SortOrder
    created_at?: SortOrder
  }

  export type inventory_transactionsMinOrderByAggregateInput = {
    transaction_id?: SortOrder
    product_id?: SortOrder
    change_type?: SortOrder
    quantity_change?: SortOrder
    related_order_id?: SortOrder
    related_return_id?: SortOrder
    created_at?: SortOrder
  }

  export type inventory_transactionsSumOrderByAggregateInput = {
    quantity_change?: SortOrder
    related_order_id?: SortOrder
    related_return_id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ordersCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutCustomerInput | ordersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutCustomerInput | ordersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutCustomerInput | ordersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutCustomerInput | ordersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutCustomerInput | ordersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutCustomerInput | ordersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type inventoryCreateNestedOneWithoutProductInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput
    connect?: inventoryWhereUniqueInput
  }

  export type order_itemsCreateNestedManyWithoutProductInput = {
    create?: XOR<order_itemsCreateWithoutProductInput, order_itemsUncheckedCreateWithoutProductInput> | order_itemsCreateWithoutProductInput[] | order_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductInput | order_itemsCreateOrConnectWithoutProductInput[]
    createMany?: order_itemsCreateManyProductInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type inventory_transactionsCreateNestedManyWithoutProductInput = {
    create?: XOR<inventory_transactionsCreateWithoutProductInput, inventory_transactionsUncheckedCreateWithoutProductInput> | inventory_transactionsCreateWithoutProductInput[] | inventory_transactionsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutProductInput | inventory_transactionsCreateOrConnectWithoutProductInput[]
    createMany?: inventory_transactionsCreateManyProductInputEnvelope
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
  }

  export type return_itemsCreateNestedManyWithoutProductInput = {
    create?: XOR<return_itemsCreateWithoutProductInput, return_itemsUncheckedCreateWithoutProductInput> | return_itemsCreateWithoutProductInput[] | return_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutProductInput | return_itemsCreateOrConnectWithoutProductInput[]
    createMany?: return_itemsCreateManyProductInputEnvelope
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
  }

  export type inventoryUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput
    connect?: inventoryWhereUniqueInput
  }

  export type order_itemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<order_itemsCreateWithoutProductInput, order_itemsUncheckedCreateWithoutProductInput> | order_itemsCreateWithoutProductInput[] | order_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductInput | order_itemsCreateOrConnectWithoutProductInput[]
    createMany?: order_itemsCreateManyProductInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type inventory_transactionsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<inventory_transactionsCreateWithoutProductInput, inventory_transactionsUncheckedCreateWithoutProductInput> | inventory_transactionsCreateWithoutProductInput[] | inventory_transactionsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutProductInput | inventory_transactionsCreateOrConnectWithoutProductInput[]
    createMany?: inventory_transactionsCreateManyProductInputEnvelope
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
  }

  export type return_itemsUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<return_itemsCreateWithoutProductInput, return_itemsUncheckedCreateWithoutProductInput> | return_itemsCreateWithoutProductInput[] | return_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutProductInput | return_itemsCreateOrConnectWithoutProductInput[]
    createMany?: return_itemsCreateManyProductInputEnvelope
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type inventoryUpdateOneWithoutProductNestedInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput
    upsert?: inventoryUpsertWithoutProductInput
    disconnect?: inventoryWhereInput | boolean
    delete?: inventoryWhereInput | boolean
    connect?: inventoryWhereUniqueInput
    update?: XOR<XOR<inventoryUpdateToOneWithWhereWithoutProductInput, inventoryUpdateWithoutProductInput>, inventoryUncheckedUpdateWithoutProductInput>
  }

  export type order_itemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<order_itemsCreateWithoutProductInput, order_itemsUncheckedCreateWithoutProductInput> | order_itemsCreateWithoutProductInput[] | order_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductInput | order_itemsCreateOrConnectWithoutProductInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutProductInput | order_itemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: order_itemsCreateManyProductInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutProductInput | order_itemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutProductInput | order_itemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type inventory_transactionsUpdateManyWithoutProductNestedInput = {
    create?: XOR<inventory_transactionsCreateWithoutProductInput, inventory_transactionsUncheckedCreateWithoutProductInput> | inventory_transactionsCreateWithoutProductInput[] | inventory_transactionsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutProductInput | inventory_transactionsCreateOrConnectWithoutProductInput[]
    upsert?: inventory_transactionsUpsertWithWhereUniqueWithoutProductInput | inventory_transactionsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: inventory_transactionsCreateManyProductInputEnvelope
    set?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    disconnect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    delete?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    update?: inventory_transactionsUpdateWithWhereUniqueWithoutProductInput | inventory_transactionsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: inventory_transactionsUpdateManyWithWhereWithoutProductInput | inventory_transactionsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
  }

  export type return_itemsUpdateManyWithoutProductNestedInput = {
    create?: XOR<return_itemsCreateWithoutProductInput, return_itemsUncheckedCreateWithoutProductInput> | return_itemsCreateWithoutProductInput[] | return_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutProductInput | return_itemsCreateOrConnectWithoutProductInput[]
    upsert?: return_itemsUpsertWithWhereUniqueWithoutProductInput | return_itemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: return_itemsCreateManyProductInputEnvelope
    set?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    disconnect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    delete?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    update?: return_itemsUpdateWithWhereUniqueWithoutProductInput | return_itemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: return_itemsUpdateManyWithWhereWithoutProductInput | return_itemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: return_itemsScalarWhereInput | return_itemsScalarWhereInput[]
  }

  export type inventoryUncheckedUpdateOneWithoutProductNestedInput = {
    create?: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
    connectOrCreate?: inventoryCreateOrConnectWithoutProductInput
    upsert?: inventoryUpsertWithoutProductInput
    disconnect?: inventoryWhereInput | boolean
    delete?: inventoryWhereInput | boolean
    connect?: inventoryWhereUniqueInput
    update?: XOR<XOR<inventoryUpdateToOneWithWhereWithoutProductInput, inventoryUpdateWithoutProductInput>, inventoryUncheckedUpdateWithoutProductInput>
  }

  export type order_itemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<order_itemsCreateWithoutProductInput, order_itemsUncheckedCreateWithoutProductInput> | order_itemsCreateWithoutProductInput[] | order_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutProductInput | order_itemsCreateOrConnectWithoutProductInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutProductInput | order_itemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: order_itemsCreateManyProductInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutProductInput | order_itemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutProductInput | order_itemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type inventory_transactionsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<inventory_transactionsCreateWithoutProductInput, inventory_transactionsUncheckedCreateWithoutProductInput> | inventory_transactionsCreateWithoutProductInput[] | inventory_transactionsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutProductInput | inventory_transactionsCreateOrConnectWithoutProductInput[]
    upsert?: inventory_transactionsUpsertWithWhereUniqueWithoutProductInput | inventory_transactionsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: inventory_transactionsCreateManyProductInputEnvelope
    set?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    disconnect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    delete?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    update?: inventory_transactionsUpdateWithWhereUniqueWithoutProductInput | inventory_transactionsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: inventory_transactionsUpdateManyWithWhereWithoutProductInput | inventory_transactionsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
  }

  export type return_itemsUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<return_itemsCreateWithoutProductInput, return_itemsUncheckedCreateWithoutProductInput> | return_itemsCreateWithoutProductInput[] | return_itemsUncheckedCreateWithoutProductInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutProductInput | return_itemsCreateOrConnectWithoutProductInput[]
    upsert?: return_itemsUpsertWithWhereUniqueWithoutProductInput | return_itemsUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: return_itemsCreateManyProductInputEnvelope
    set?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    disconnect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    delete?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    update?: return_itemsUpdateWithWhereUniqueWithoutProductInput | return_itemsUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: return_itemsUpdateManyWithWhereWithoutProductInput | return_itemsUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: return_itemsScalarWhereInput | return_itemsScalarWhereInput[]
  }

  export type productsCreateNestedOneWithoutInventoryInput = {
    create?: XOR<productsCreateWithoutInventoryInput, productsUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: productsCreateOrConnectWithoutInventoryInput
    connect?: productsWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type productsUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<productsCreateWithoutInventoryInput, productsUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: productsCreateOrConnectWithoutInventoryInput
    upsert?: productsUpsertWithoutInventoryInput
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutInventoryInput, productsUpdateWithoutInventoryInput>, productsUncheckedUpdateWithoutInventoryInput>
  }

  export type customersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customersCreateOrConnectWithoutOrdersInput
    connect?: customersWhereUniqueInput
  }

  export type order_itemsCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_itemsCreateWithoutOrderInput, order_itemsUncheckedCreateWithoutOrderInput> | order_itemsCreateWithoutOrderInput[] | order_itemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrderInput | order_itemsCreateOrConnectWithoutOrderInput[]
    createMany?: order_itemsCreateManyOrderInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type order_paymentsCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_paymentsCreateWithoutOrderInput, order_paymentsUncheckedCreateWithoutOrderInput> | order_paymentsCreateWithoutOrderInput[] | order_paymentsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutOrderInput | order_paymentsCreateOrConnectWithoutOrderInput[]
    createMany?: order_paymentsCreateManyOrderInputEnvelope
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
  }

  export type returnsCreateNestedOneWithoutOrderInput = {
    create?: XOR<returnsCreateWithoutOrderInput, returnsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: returnsCreateOrConnectWithoutOrderInput
    connect?: returnsWhereUniqueInput
  }

  export type inventory_transactionsCreateNestedManyWithoutOrderInput = {
    create?: XOR<inventory_transactionsCreateWithoutOrderInput, inventory_transactionsUncheckedCreateWithoutOrderInput> | inventory_transactionsCreateWithoutOrderInput[] | inventory_transactionsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutOrderInput | inventory_transactionsCreateOrConnectWithoutOrderInput[]
    createMany?: inventory_transactionsCreateManyOrderInputEnvelope
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
  }

  export type order_itemsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_itemsCreateWithoutOrderInput, order_itemsUncheckedCreateWithoutOrderInput> | order_itemsCreateWithoutOrderInput[] | order_itemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrderInput | order_itemsCreateOrConnectWithoutOrderInput[]
    createMany?: order_itemsCreateManyOrderInputEnvelope
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
  }

  export type order_paymentsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_paymentsCreateWithoutOrderInput, order_paymentsUncheckedCreateWithoutOrderInput> | order_paymentsCreateWithoutOrderInput[] | order_paymentsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutOrderInput | order_paymentsCreateOrConnectWithoutOrderInput[]
    createMany?: order_paymentsCreateManyOrderInputEnvelope
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
  }

  export type returnsUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<returnsCreateWithoutOrderInput, returnsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: returnsCreateOrConnectWithoutOrderInput
    connect?: returnsWhereUniqueInput
  }

  export type inventory_transactionsUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<inventory_transactionsCreateWithoutOrderInput, inventory_transactionsUncheckedCreateWithoutOrderInput> | inventory_transactionsCreateWithoutOrderInput[] | inventory_transactionsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutOrderInput | inventory_transactionsCreateOrConnectWithoutOrderInput[]
    createMany?: inventory_transactionsCreateManyOrderInputEnvelope
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
  }

  export type customersUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customersCreateOrConnectWithoutOrdersInput
    upsert?: customersUpsertWithoutOrdersInput
    disconnect?: customersWhereInput | boolean
    delete?: customersWhereInput | boolean
    connect?: customersWhereUniqueInput
    update?: XOR<XOR<customersUpdateToOneWithWhereWithoutOrdersInput, customersUpdateWithoutOrdersInput>, customersUncheckedUpdateWithoutOrdersInput>
  }

  export type order_itemsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_itemsCreateWithoutOrderInput, order_itemsUncheckedCreateWithoutOrderInput> | order_itemsCreateWithoutOrderInput[] | order_itemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrderInput | order_itemsCreateOrConnectWithoutOrderInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutOrderInput | order_itemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_itemsCreateManyOrderInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutOrderInput | order_itemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutOrderInput | order_itemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type order_paymentsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_paymentsCreateWithoutOrderInput, order_paymentsUncheckedCreateWithoutOrderInput> | order_paymentsCreateWithoutOrderInput[] | order_paymentsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutOrderInput | order_paymentsCreateOrConnectWithoutOrderInput[]
    upsert?: order_paymentsUpsertWithWhereUniqueWithoutOrderInput | order_paymentsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_paymentsCreateManyOrderInputEnvelope
    set?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    disconnect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    delete?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    update?: order_paymentsUpdateWithWhereUniqueWithoutOrderInput | order_paymentsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_paymentsUpdateManyWithWhereWithoutOrderInput | order_paymentsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_paymentsScalarWhereInput | order_paymentsScalarWhereInput[]
  }

  export type returnsUpdateOneWithoutOrderNestedInput = {
    create?: XOR<returnsCreateWithoutOrderInput, returnsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: returnsCreateOrConnectWithoutOrderInput
    upsert?: returnsUpsertWithoutOrderInput
    disconnect?: returnsWhereInput | boolean
    delete?: returnsWhereInput | boolean
    connect?: returnsWhereUniqueInput
    update?: XOR<XOR<returnsUpdateToOneWithWhereWithoutOrderInput, returnsUpdateWithoutOrderInput>, returnsUncheckedUpdateWithoutOrderInput>
  }

  export type inventory_transactionsUpdateManyWithoutOrderNestedInput = {
    create?: XOR<inventory_transactionsCreateWithoutOrderInput, inventory_transactionsUncheckedCreateWithoutOrderInput> | inventory_transactionsCreateWithoutOrderInput[] | inventory_transactionsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutOrderInput | inventory_transactionsCreateOrConnectWithoutOrderInput[]
    upsert?: inventory_transactionsUpsertWithWhereUniqueWithoutOrderInput | inventory_transactionsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: inventory_transactionsCreateManyOrderInputEnvelope
    set?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    disconnect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    delete?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    update?: inventory_transactionsUpdateWithWhereUniqueWithoutOrderInput | inventory_transactionsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: inventory_transactionsUpdateManyWithWhereWithoutOrderInput | inventory_transactionsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
  }

  export type order_itemsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_itemsCreateWithoutOrderInput, order_itemsUncheckedCreateWithoutOrderInput> | order_itemsCreateWithoutOrderInput[] | order_itemsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_itemsCreateOrConnectWithoutOrderInput | order_itemsCreateOrConnectWithoutOrderInput[]
    upsert?: order_itemsUpsertWithWhereUniqueWithoutOrderInput | order_itemsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_itemsCreateManyOrderInputEnvelope
    set?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    disconnect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    delete?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    connect?: order_itemsWhereUniqueInput | order_itemsWhereUniqueInput[]
    update?: order_itemsUpdateWithWhereUniqueWithoutOrderInput | order_itemsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_itemsUpdateManyWithWhereWithoutOrderInput | order_itemsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
  }

  export type order_paymentsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_paymentsCreateWithoutOrderInput, order_paymentsUncheckedCreateWithoutOrderInput> | order_paymentsCreateWithoutOrderInput[] | order_paymentsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutOrderInput | order_paymentsCreateOrConnectWithoutOrderInput[]
    upsert?: order_paymentsUpsertWithWhereUniqueWithoutOrderInput | order_paymentsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_paymentsCreateManyOrderInputEnvelope
    set?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    disconnect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    delete?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    update?: order_paymentsUpdateWithWhereUniqueWithoutOrderInput | order_paymentsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_paymentsUpdateManyWithWhereWithoutOrderInput | order_paymentsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_paymentsScalarWhereInput | order_paymentsScalarWhereInput[]
  }

  export type returnsUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<returnsCreateWithoutOrderInput, returnsUncheckedCreateWithoutOrderInput>
    connectOrCreate?: returnsCreateOrConnectWithoutOrderInput
    upsert?: returnsUpsertWithoutOrderInput
    disconnect?: returnsWhereInput | boolean
    delete?: returnsWhereInput | boolean
    connect?: returnsWhereUniqueInput
    update?: XOR<XOR<returnsUpdateToOneWithWhereWithoutOrderInput, returnsUpdateWithoutOrderInput>, returnsUncheckedUpdateWithoutOrderInput>
  }

  export type inventory_transactionsUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<inventory_transactionsCreateWithoutOrderInput, inventory_transactionsUncheckedCreateWithoutOrderInput> | inventory_transactionsCreateWithoutOrderInput[] | inventory_transactionsUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutOrderInput | inventory_transactionsCreateOrConnectWithoutOrderInput[]
    upsert?: inventory_transactionsUpsertWithWhereUniqueWithoutOrderInput | inventory_transactionsUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: inventory_transactionsCreateManyOrderInputEnvelope
    set?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    disconnect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    delete?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    update?: inventory_transactionsUpdateWithWhereUniqueWithoutOrderInput | inventory_transactionsUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: inventory_transactionsUpdateManyWithWhereWithoutOrderInput | inventory_transactionsUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
  }

  export type ordersCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrder_itemsInput
    connect?: ordersWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutOrder_itemsInput
    connect?: productsWhereUniqueInput
  }

  export type ordersUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrder_itemsInput
    upsert?: ordersUpsertWithoutOrder_itemsInput
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutOrder_itemsInput, ordersUpdateWithoutOrder_itemsInput>, ordersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type productsUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutOrder_itemsInput
    upsert?: productsUpsertWithoutOrder_itemsInput
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutOrder_itemsInput, productsUpdateWithoutOrder_itemsInput>, productsUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type order_paymentsCreateNestedManyWithoutPayment_methodsInput = {
    create?: XOR<order_paymentsCreateWithoutPayment_methodsInput, order_paymentsUncheckedCreateWithoutPayment_methodsInput> | order_paymentsCreateWithoutPayment_methodsInput[] | order_paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutPayment_methodsInput | order_paymentsCreateOrConnectWithoutPayment_methodsInput[]
    createMany?: order_paymentsCreateManyPayment_methodsInputEnvelope
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
  }

  export type order_paymentsUncheckedCreateNestedManyWithoutPayment_methodsInput = {
    create?: XOR<order_paymentsCreateWithoutPayment_methodsInput, order_paymentsUncheckedCreateWithoutPayment_methodsInput> | order_paymentsCreateWithoutPayment_methodsInput[] | order_paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutPayment_methodsInput | order_paymentsCreateOrConnectWithoutPayment_methodsInput[]
    createMany?: order_paymentsCreateManyPayment_methodsInputEnvelope
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
  }

  export type order_paymentsUpdateManyWithoutPayment_methodsNestedInput = {
    create?: XOR<order_paymentsCreateWithoutPayment_methodsInput, order_paymentsUncheckedCreateWithoutPayment_methodsInput> | order_paymentsCreateWithoutPayment_methodsInput[] | order_paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutPayment_methodsInput | order_paymentsCreateOrConnectWithoutPayment_methodsInput[]
    upsert?: order_paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput | order_paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput[]
    createMany?: order_paymentsCreateManyPayment_methodsInputEnvelope
    set?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    disconnect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    delete?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    update?: order_paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput | order_paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput[]
    updateMany?: order_paymentsUpdateManyWithWhereWithoutPayment_methodsInput | order_paymentsUpdateManyWithWhereWithoutPayment_methodsInput[]
    deleteMany?: order_paymentsScalarWhereInput | order_paymentsScalarWhereInput[]
  }

  export type order_paymentsUncheckedUpdateManyWithoutPayment_methodsNestedInput = {
    create?: XOR<order_paymentsCreateWithoutPayment_methodsInput, order_paymentsUncheckedCreateWithoutPayment_methodsInput> | order_paymentsCreateWithoutPayment_methodsInput[] | order_paymentsUncheckedCreateWithoutPayment_methodsInput[]
    connectOrCreate?: order_paymentsCreateOrConnectWithoutPayment_methodsInput | order_paymentsCreateOrConnectWithoutPayment_methodsInput[]
    upsert?: order_paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput | order_paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput[]
    createMany?: order_paymentsCreateManyPayment_methodsInputEnvelope
    set?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    disconnect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    delete?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    connect?: order_paymentsWhereUniqueInput | order_paymentsWhereUniqueInput[]
    update?: order_paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput | order_paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput[]
    updateMany?: order_paymentsUpdateManyWithWhereWithoutPayment_methodsInput | order_paymentsUpdateManyWithWhereWithoutPayment_methodsInput[]
    deleteMany?: order_paymentsScalarWhereInput | order_paymentsScalarWhereInput[]
  }

  export type ordersCreateNestedOneWithoutOrder_paymentsInput = {
    create?: XOR<ordersCreateWithoutOrder_paymentsInput, ordersUncheckedCreateWithoutOrder_paymentsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrder_paymentsInput
    connect?: ordersWhereUniqueInput
  }

  export type payment_methodsCreateNestedOneWithoutOrder_paymentsInput = {
    create?: XOR<payment_methodsCreateWithoutOrder_paymentsInput, payment_methodsUncheckedCreateWithoutOrder_paymentsInput>
    connectOrCreate?: payment_methodsCreateOrConnectWithoutOrder_paymentsInput
    connect?: payment_methodsWhereUniqueInput
  }

  export type ordersUpdateOneRequiredWithoutOrder_paymentsNestedInput = {
    create?: XOR<ordersCreateWithoutOrder_paymentsInput, ordersUncheckedCreateWithoutOrder_paymentsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrder_paymentsInput
    upsert?: ordersUpsertWithoutOrder_paymentsInput
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutOrder_paymentsInput, ordersUpdateWithoutOrder_paymentsInput>, ordersUncheckedUpdateWithoutOrder_paymentsInput>
  }

  export type payment_methodsUpdateOneRequiredWithoutOrder_paymentsNestedInput = {
    create?: XOR<payment_methodsCreateWithoutOrder_paymentsInput, payment_methodsUncheckedCreateWithoutOrder_paymentsInput>
    connectOrCreate?: payment_methodsCreateOrConnectWithoutOrder_paymentsInput
    upsert?: payment_methodsUpsertWithoutOrder_paymentsInput
    connect?: payment_methodsWhereUniqueInput
    update?: XOR<XOR<payment_methodsUpdateToOneWithWhereWithoutOrder_paymentsInput, payment_methodsUpdateWithoutOrder_paymentsInput>, payment_methodsUncheckedUpdateWithoutOrder_paymentsInput>
  }

  export type ordersCreateNestedOneWithoutReturnsInput = {
    create?: XOR<ordersCreateWithoutReturnsInput, ordersUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutReturnsInput
    connect?: ordersWhereUniqueInput
  }

  export type return_itemsCreateNestedManyWithoutReturnsInput = {
    create?: XOR<return_itemsCreateWithoutReturnsInput, return_itemsUncheckedCreateWithoutReturnsInput> | return_itemsCreateWithoutReturnsInput[] | return_itemsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutReturnsInput | return_itemsCreateOrConnectWithoutReturnsInput[]
    createMany?: return_itemsCreateManyReturnsInputEnvelope
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
  }

  export type inventory_transactionsCreateNestedManyWithoutReturnsInput = {
    create?: XOR<inventory_transactionsCreateWithoutReturnsInput, inventory_transactionsUncheckedCreateWithoutReturnsInput> | inventory_transactionsCreateWithoutReturnsInput[] | inventory_transactionsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutReturnsInput | inventory_transactionsCreateOrConnectWithoutReturnsInput[]
    createMany?: inventory_transactionsCreateManyReturnsInputEnvelope
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
  }

  export type return_itemsUncheckedCreateNestedManyWithoutReturnsInput = {
    create?: XOR<return_itemsCreateWithoutReturnsInput, return_itemsUncheckedCreateWithoutReturnsInput> | return_itemsCreateWithoutReturnsInput[] | return_itemsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutReturnsInput | return_itemsCreateOrConnectWithoutReturnsInput[]
    createMany?: return_itemsCreateManyReturnsInputEnvelope
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
  }

  export type inventory_transactionsUncheckedCreateNestedManyWithoutReturnsInput = {
    create?: XOR<inventory_transactionsCreateWithoutReturnsInput, inventory_transactionsUncheckedCreateWithoutReturnsInput> | inventory_transactionsCreateWithoutReturnsInput[] | inventory_transactionsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutReturnsInput | inventory_transactionsCreateOrConnectWithoutReturnsInput[]
    createMany?: inventory_transactionsCreateManyReturnsInputEnvelope
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
  }

  export type ordersUpdateOneWithoutReturnsNestedInput = {
    create?: XOR<ordersCreateWithoutReturnsInput, ordersUncheckedCreateWithoutReturnsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutReturnsInput
    upsert?: ordersUpsertWithoutReturnsInput
    disconnect?: ordersWhereInput | boolean
    delete?: ordersWhereInput | boolean
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutReturnsInput, ordersUpdateWithoutReturnsInput>, ordersUncheckedUpdateWithoutReturnsInput>
  }

  export type return_itemsUpdateManyWithoutReturnsNestedInput = {
    create?: XOR<return_itemsCreateWithoutReturnsInput, return_itemsUncheckedCreateWithoutReturnsInput> | return_itemsCreateWithoutReturnsInput[] | return_itemsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutReturnsInput | return_itemsCreateOrConnectWithoutReturnsInput[]
    upsert?: return_itemsUpsertWithWhereUniqueWithoutReturnsInput | return_itemsUpsertWithWhereUniqueWithoutReturnsInput[]
    createMany?: return_itemsCreateManyReturnsInputEnvelope
    set?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    disconnect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    delete?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    update?: return_itemsUpdateWithWhereUniqueWithoutReturnsInput | return_itemsUpdateWithWhereUniqueWithoutReturnsInput[]
    updateMany?: return_itemsUpdateManyWithWhereWithoutReturnsInput | return_itemsUpdateManyWithWhereWithoutReturnsInput[]
    deleteMany?: return_itemsScalarWhereInput | return_itemsScalarWhereInput[]
  }

  export type inventory_transactionsUpdateManyWithoutReturnsNestedInput = {
    create?: XOR<inventory_transactionsCreateWithoutReturnsInput, inventory_transactionsUncheckedCreateWithoutReturnsInput> | inventory_transactionsCreateWithoutReturnsInput[] | inventory_transactionsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutReturnsInput | inventory_transactionsCreateOrConnectWithoutReturnsInput[]
    upsert?: inventory_transactionsUpsertWithWhereUniqueWithoutReturnsInput | inventory_transactionsUpsertWithWhereUniqueWithoutReturnsInput[]
    createMany?: inventory_transactionsCreateManyReturnsInputEnvelope
    set?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    disconnect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    delete?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    update?: inventory_transactionsUpdateWithWhereUniqueWithoutReturnsInput | inventory_transactionsUpdateWithWhereUniqueWithoutReturnsInput[]
    updateMany?: inventory_transactionsUpdateManyWithWhereWithoutReturnsInput | inventory_transactionsUpdateManyWithWhereWithoutReturnsInput[]
    deleteMany?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type return_itemsUncheckedUpdateManyWithoutReturnsNestedInput = {
    create?: XOR<return_itemsCreateWithoutReturnsInput, return_itemsUncheckedCreateWithoutReturnsInput> | return_itemsCreateWithoutReturnsInput[] | return_itemsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: return_itemsCreateOrConnectWithoutReturnsInput | return_itemsCreateOrConnectWithoutReturnsInput[]
    upsert?: return_itemsUpsertWithWhereUniqueWithoutReturnsInput | return_itemsUpsertWithWhereUniqueWithoutReturnsInput[]
    createMany?: return_itemsCreateManyReturnsInputEnvelope
    set?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    disconnect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    delete?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    connect?: return_itemsWhereUniqueInput | return_itemsWhereUniqueInput[]
    update?: return_itemsUpdateWithWhereUniqueWithoutReturnsInput | return_itemsUpdateWithWhereUniqueWithoutReturnsInput[]
    updateMany?: return_itemsUpdateManyWithWhereWithoutReturnsInput | return_itemsUpdateManyWithWhereWithoutReturnsInput[]
    deleteMany?: return_itemsScalarWhereInput | return_itemsScalarWhereInput[]
  }

  export type inventory_transactionsUncheckedUpdateManyWithoutReturnsNestedInput = {
    create?: XOR<inventory_transactionsCreateWithoutReturnsInput, inventory_transactionsUncheckedCreateWithoutReturnsInput> | inventory_transactionsCreateWithoutReturnsInput[] | inventory_transactionsUncheckedCreateWithoutReturnsInput[]
    connectOrCreate?: inventory_transactionsCreateOrConnectWithoutReturnsInput | inventory_transactionsCreateOrConnectWithoutReturnsInput[]
    upsert?: inventory_transactionsUpsertWithWhereUniqueWithoutReturnsInput | inventory_transactionsUpsertWithWhereUniqueWithoutReturnsInput[]
    createMany?: inventory_transactionsCreateManyReturnsInputEnvelope
    set?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    disconnect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    delete?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    connect?: inventory_transactionsWhereUniqueInput | inventory_transactionsWhereUniqueInput[]
    update?: inventory_transactionsUpdateWithWhereUniqueWithoutReturnsInput | inventory_transactionsUpdateWithWhereUniqueWithoutReturnsInput[]
    updateMany?: inventory_transactionsUpdateManyWithWhereWithoutReturnsInput | inventory_transactionsUpdateManyWithWhereWithoutReturnsInput[]
    deleteMany?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
  }

  export type returnsCreateNestedOneWithoutReturn_itemsInput = {
    create?: XOR<returnsCreateWithoutReturn_itemsInput, returnsUncheckedCreateWithoutReturn_itemsInput>
    connectOrCreate?: returnsCreateOrConnectWithoutReturn_itemsInput
    connect?: returnsWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutReturn_itemsInput = {
    create?: XOR<productsCreateWithoutReturn_itemsInput, productsUncheckedCreateWithoutReturn_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutReturn_itemsInput
    connect?: productsWhereUniqueInput
  }

  export type returnsUpdateOneRequiredWithoutReturn_itemsNestedInput = {
    create?: XOR<returnsCreateWithoutReturn_itemsInput, returnsUncheckedCreateWithoutReturn_itemsInput>
    connectOrCreate?: returnsCreateOrConnectWithoutReturn_itemsInput
    upsert?: returnsUpsertWithoutReturn_itemsInput
    connect?: returnsWhereUniqueInput
    update?: XOR<XOR<returnsUpdateToOneWithWhereWithoutReturn_itemsInput, returnsUpdateWithoutReturn_itemsInput>, returnsUncheckedUpdateWithoutReturn_itemsInput>
  }

  export type productsUpdateOneRequiredWithoutReturn_itemsNestedInput = {
    create?: XOR<productsCreateWithoutReturn_itemsInput, productsUncheckedCreateWithoutReturn_itemsInput>
    connectOrCreate?: productsCreateOrConnectWithoutReturn_itemsInput
    upsert?: productsUpsertWithoutReturn_itemsInput
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutReturn_itemsInput, productsUpdateWithoutReturn_itemsInput>, productsUncheckedUpdateWithoutReturn_itemsInput>
  }

  export type productsCreateNestedOneWithoutInventory_transactionsInput = {
    create?: XOR<productsCreateWithoutInventory_transactionsInput, productsUncheckedCreateWithoutInventory_transactionsInput>
    connectOrCreate?: productsCreateOrConnectWithoutInventory_transactionsInput
    connect?: productsWhereUniqueInput
  }

  export type ordersCreateNestedOneWithoutInventory_transactionsInput = {
    create?: XOR<ordersCreateWithoutInventory_transactionsInput, ordersUncheckedCreateWithoutInventory_transactionsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutInventory_transactionsInput
    connect?: ordersWhereUniqueInput
  }

  export type returnsCreateNestedOneWithoutInventory_transactionsInput = {
    create?: XOR<returnsCreateWithoutInventory_transactionsInput, returnsUncheckedCreateWithoutInventory_transactionsInput>
    connectOrCreate?: returnsCreateOrConnectWithoutInventory_transactionsInput
    connect?: returnsWhereUniqueInput
  }

  export type productsUpdateOneRequiredWithoutInventory_transactionsNestedInput = {
    create?: XOR<productsCreateWithoutInventory_transactionsInput, productsUncheckedCreateWithoutInventory_transactionsInput>
    connectOrCreate?: productsCreateOrConnectWithoutInventory_transactionsInput
    upsert?: productsUpsertWithoutInventory_transactionsInput
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutInventory_transactionsInput, productsUpdateWithoutInventory_transactionsInput>, productsUncheckedUpdateWithoutInventory_transactionsInput>
  }

  export type ordersUpdateOneWithoutInventory_transactionsNestedInput = {
    create?: XOR<ordersCreateWithoutInventory_transactionsInput, ordersUncheckedCreateWithoutInventory_transactionsInput>
    connectOrCreate?: ordersCreateOrConnectWithoutInventory_transactionsInput
    upsert?: ordersUpsertWithoutInventory_transactionsInput
    disconnect?: ordersWhereInput | boolean
    delete?: ordersWhereInput | boolean
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutInventory_transactionsInput, ordersUpdateWithoutInventory_transactionsInput>, ordersUncheckedUpdateWithoutInventory_transactionsInput>
  }

  export type returnsUpdateOneWithoutInventory_transactionsNestedInput = {
    create?: XOR<returnsCreateWithoutInventory_transactionsInput, returnsUncheckedCreateWithoutInventory_transactionsInput>
    connectOrCreate?: returnsCreateOrConnectWithoutInventory_transactionsInput
    upsert?: returnsUpsertWithoutInventory_transactionsInput
    disconnect?: returnsWhereInput | boolean
    delete?: returnsWhereInput | boolean
    connect?: returnsWhereUniqueInput
    update?: XOR<XOR<returnsUpdateToOneWithWhereWithoutInventory_transactionsInput, returnsUpdateWithoutInventory_transactionsInput>, returnsUncheckedUpdateWithoutInventory_transactionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ordersCreateWithoutCustomerInput = {
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    order_items?: order_itemsCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsCreateNestedManyWithoutOrderInput
    returns?: returnsCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutCustomerInput = {
    order_id?: number
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsUncheckedCreateNestedManyWithoutOrderInput
    returns?: returnsUncheckedCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutCustomerInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput>
  }

  export type ordersCreateManyCustomerInputEnvelope = {
    data: ordersCreateManyCustomerInput | ordersCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ordersUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutCustomerInput, ordersUncheckedUpdateWithoutCustomerInput>
    create: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutCustomerInput, ordersUncheckedUpdateWithoutCustomerInput>
  }

  export type ordersUpdateManyWithWhereWithoutCustomerInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ordersScalarWhereInput = {
    AND?: ordersScalarWhereInput | ordersScalarWhereInput[]
    OR?: ordersScalarWhereInput[]
    NOT?: ordersScalarWhereInput | ordersScalarWhereInput[]
    order_id?: IntFilter<"orders"> | number
    customer_id?: StringNullableFilter<"orders"> | string | null
    order_date?: DateTimeFilter<"orders"> | Date | string
    status?: StringFilter<"orders"> | string
    total_amount?: DecimalFilter<"orders"> | Decimal | DecimalJsLike | number | string
  }

  export type inventoryCreateWithoutProductInput = {
    inventory_id?: string
    quantity: number
    updated_at?: Date | string
  }

  export type inventoryUncheckedCreateWithoutProductInput = {
    inventory_id?: string
    quantity: number
    updated_at?: Date | string
  }

  export type inventoryCreateOrConnectWithoutProductInput = {
    where: inventoryWhereUniqueInput
    create: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
  }

  export type order_itemsCreateWithoutProductInput = {
    order_item_id?: string
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    order: ordersCreateNestedOneWithoutOrder_itemsInput
  }

  export type order_itemsUncheckedCreateWithoutProductInput = {
    order_item_id?: string
    order_id: number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type order_itemsCreateOrConnectWithoutProductInput = {
    where: order_itemsWhereUniqueInput
    create: XOR<order_itemsCreateWithoutProductInput, order_itemsUncheckedCreateWithoutProductInput>
  }

  export type order_itemsCreateManyProductInputEnvelope = {
    data: order_itemsCreateManyProductInput | order_itemsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type inventory_transactionsCreateWithoutProductInput = {
    transaction_id?: string
    change_type: string
    quantity_change: number
    created_at?: Date | string
    order?: ordersCreateNestedOneWithoutInventory_transactionsInput
    returns?: returnsCreateNestedOneWithoutInventory_transactionsInput
  }

  export type inventory_transactionsUncheckedCreateWithoutProductInput = {
    transaction_id?: string
    change_type: string
    quantity_change: number
    related_order_id?: number | null
    related_return_id?: number | null
    created_at?: Date | string
  }

  export type inventory_transactionsCreateOrConnectWithoutProductInput = {
    where: inventory_transactionsWhereUniqueInput
    create: XOR<inventory_transactionsCreateWithoutProductInput, inventory_transactionsUncheckedCreateWithoutProductInput>
  }

  export type inventory_transactionsCreateManyProductInputEnvelope = {
    data: inventory_transactionsCreateManyProductInput | inventory_transactionsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type return_itemsCreateWithoutProductInput = {
    return_item_id?: string
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
    returns: returnsCreateNestedOneWithoutReturn_itemsInput
  }

  export type return_itemsUncheckedCreateWithoutProductInput = {
    return_item_id?: string
    return_id: number
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
  }

  export type return_itemsCreateOrConnectWithoutProductInput = {
    where: return_itemsWhereUniqueInput
    create: XOR<return_itemsCreateWithoutProductInput, return_itemsUncheckedCreateWithoutProductInput>
  }

  export type return_itemsCreateManyProductInputEnvelope = {
    data: return_itemsCreateManyProductInput | return_itemsCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type inventoryUpsertWithoutProductInput = {
    update: XOR<inventoryUpdateWithoutProductInput, inventoryUncheckedUpdateWithoutProductInput>
    create: XOR<inventoryCreateWithoutProductInput, inventoryUncheckedCreateWithoutProductInput>
    where?: inventoryWhereInput
  }

  export type inventoryUpdateToOneWithWhereWithoutProductInput = {
    where?: inventoryWhereInput
    data: XOR<inventoryUpdateWithoutProductInput, inventoryUncheckedUpdateWithoutProductInput>
  }

  export type inventoryUpdateWithoutProductInput = {
    inventory_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventoryUncheckedUpdateWithoutProductInput = {
    inventory_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_itemsUpsertWithWhereUniqueWithoutProductInput = {
    where: order_itemsWhereUniqueInput
    update: XOR<order_itemsUpdateWithoutProductInput, order_itemsUncheckedUpdateWithoutProductInput>
    create: XOR<order_itemsCreateWithoutProductInput, order_itemsUncheckedCreateWithoutProductInput>
  }

  export type order_itemsUpdateWithWhereUniqueWithoutProductInput = {
    where: order_itemsWhereUniqueInput
    data: XOR<order_itemsUpdateWithoutProductInput, order_itemsUncheckedUpdateWithoutProductInput>
  }

  export type order_itemsUpdateManyWithWhereWithoutProductInput = {
    where: order_itemsScalarWhereInput
    data: XOR<order_itemsUpdateManyMutationInput, order_itemsUncheckedUpdateManyWithoutProductInput>
  }

  export type order_itemsScalarWhereInput = {
    AND?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
    OR?: order_itemsScalarWhereInput[]
    NOT?: order_itemsScalarWhereInput | order_itemsScalarWhereInput[]
    order_item_id?: StringFilter<"order_items"> | string
    order_id?: IntFilter<"order_items"> | number
    product_id?: StringFilter<"order_items"> | string
    quantity?: IntFilter<"order_items"> | number
    unit_price?: DecimalFilter<"order_items"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"order_items"> | Decimal | DecimalJsLike | number | string
  }

  export type inventory_transactionsUpsertWithWhereUniqueWithoutProductInput = {
    where: inventory_transactionsWhereUniqueInput
    update: XOR<inventory_transactionsUpdateWithoutProductInput, inventory_transactionsUncheckedUpdateWithoutProductInput>
    create: XOR<inventory_transactionsCreateWithoutProductInput, inventory_transactionsUncheckedCreateWithoutProductInput>
  }

  export type inventory_transactionsUpdateWithWhereUniqueWithoutProductInput = {
    where: inventory_transactionsWhereUniqueInput
    data: XOR<inventory_transactionsUpdateWithoutProductInput, inventory_transactionsUncheckedUpdateWithoutProductInput>
  }

  export type inventory_transactionsUpdateManyWithWhereWithoutProductInput = {
    where: inventory_transactionsScalarWhereInput
    data: XOR<inventory_transactionsUpdateManyMutationInput, inventory_transactionsUncheckedUpdateManyWithoutProductInput>
  }

  export type inventory_transactionsScalarWhereInput = {
    AND?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
    OR?: inventory_transactionsScalarWhereInput[]
    NOT?: inventory_transactionsScalarWhereInput | inventory_transactionsScalarWhereInput[]
    transaction_id?: StringFilter<"inventory_transactions"> | string
    product_id?: StringFilter<"inventory_transactions"> | string
    change_type?: StringFilter<"inventory_transactions"> | string
    quantity_change?: IntFilter<"inventory_transactions"> | number
    related_order_id?: IntNullableFilter<"inventory_transactions"> | number | null
    related_return_id?: IntNullableFilter<"inventory_transactions"> | number | null
    created_at?: DateTimeFilter<"inventory_transactions"> | Date | string
  }

  export type return_itemsUpsertWithWhereUniqueWithoutProductInput = {
    where: return_itemsWhereUniqueInput
    update: XOR<return_itemsUpdateWithoutProductInput, return_itemsUncheckedUpdateWithoutProductInput>
    create: XOR<return_itemsCreateWithoutProductInput, return_itemsUncheckedCreateWithoutProductInput>
  }

  export type return_itemsUpdateWithWhereUniqueWithoutProductInput = {
    where: return_itemsWhereUniqueInput
    data: XOR<return_itemsUpdateWithoutProductInput, return_itemsUncheckedUpdateWithoutProductInput>
  }

  export type return_itemsUpdateManyWithWhereWithoutProductInput = {
    where: return_itemsScalarWhereInput
    data: XOR<return_itemsUpdateManyMutationInput, return_itemsUncheckedUpdateManyWithoutProductInput>
  }

  export type return_itemsScalarWhereInput = {
    AND?: return_itemsScalarWhereInput | return_itemsScalarWhereInput[]
    OR?: return_itemsScalarWhereInput[]
    NOT?: return_itemsScalarWhereInput | return_itemsScalarWhereInput[]
    return_item_id?: StringFilter<"return_items"> | string
    return_id?: IntFilter<"return_items"> | number
    product_id?: StringFilter<"return_items"> | string
    quantity?: IntFilter<"return_items"> | number
    refund_amount?: DecimalFilter<"return_items"> | Decimal | DecimalJsLike | number | string
  }

  export type productsCreateWithoutInventoryInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    order_items?: order_itemsCreateNestedManyWithoutProductInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutProductInput
    return_items?: return_itemsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutInventoryInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutProductInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutProductInput
    return_items?: return_itemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutInventoryInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutInventoryInput, productsUncheckedCreateWithoutInventoryInput>
  }

  export type productsUpsertWithoutInventoryInput = {
    update: XOR<productsUpdateWithoutInventoryInput, productsUncheckedUpdateWithoutInventoryInput>
    create: XOR<productsCreateWithoutInventoryInput, productsUncheckedCreateWithoutInventoryInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutInventoryInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutInventoryInput, productsUncheckedUpdateWithoutInventoryInput>
  }

  export type productsUpdateWithoutInventoryInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUpdateManyWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutInventoryInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order_items?: order_itemsUncheckedUpdateManyWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type customersCreateWithoutOrdersInput = {
    customer_id?: string
    name: string
    email?: string | null
    phone?: string | null
    created_at?: Date | string
  }

  export type customersUncheckedCreateWithoutOrdersInput = {
    customer_id?: string
    name: string
    email?: string | null
    phone?: string | null
    created_at?: Date | string
  }

  export type customersCreateOrConnectWithoutOrdersInput = {
    where: customersWhereUniqueInput
    create: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
  }

  export type order_itemsCreateWithoutOrderInput = {
    order_item_id?: string
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    product: productsCreateNestedOneWithoutOrder_itemsInput
  }

  export type order_itemsUncheckedCreateWithoutOrderInput = {
    order_item_id?: string
    product_id: string
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type order_itemsCreateOrConnectWithoutOrderInput = {
    where: order_itemsWhereUniqueInput
    create: XOR<order_itemsCreateWithoutOrderInput, order_itemsUncheckedCreateWithoutOrderInput>
  }

  export type order_itemsCreateManyOrderInputEnvelope = {
    data: order_itemsCreateManyOrderInput | order_itemsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type order_paymentsCreateWithoutOrderInput = {
    order_payment_id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
    payment_methods: payment_methodsCreateNestedOneWithoutOrder_paymentsInput
  }

  export type order_paymentsUncheckedCreateWithoutOrderInput = {
    order_payment_id?: string
    payment_method_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
  }

  export type order_paymentsCreateOrConnectWithoutOrderInput = {
    where: order_paymentsWhereUniqueInput
    create: XOR<order_paymentsCreateWithoutOrderInput, order_paymentsUncheckedCreateWithoutOrderInput>
  }

  export type order_paymentsCreateManyOrderInputEnvelope = {
    data: order_paymentsCreateManyOrderInput | order_paymentsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type returnsCreateWithoutOrderInput = {
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    return_items?: return_itemsCreateNestedManyWithoutReturnsInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutReturnsInput
  }

  export type returnsUncheckedCreateWithoutOrderInput = {
    return_id?: number
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    return_items?: return_itemsUncheckedCreateNestedManyWithoutReturnsInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutReturnsInput
  }

  export type returnsCreateOrConnectWithoutOrderInput = {
    where: returnsWhereUniqueInput
    create: XOR<returnsCreateWithoutOrderInput, returnsUncheckedCreateWithoutOrderInput>
  }

  export type inventory_transactionsCreateWithoutOrderInput = {
    transaction_id?: string
    change_type: string
    quantity_change: number
    created_at?: Date | string
    product: productsCreateNestedOneWithoutInventory_transactionsInput
    returns?: returnsCreateNestedOneWithoutInventory_transactionsInput
  }

  export type inventory_transactionsUncheckedCreateWithoutOrderInput = {
    transaction_id?: string
    product_id: string
    change_type: string
    quantity_change: number
    related_return_id?: number | null
    created_at?: Date | string
  }

  export type inventory_transactionsCreateOrConnectWithoutOrderInput = {
    where: inventory_transactionsWhereUniqueInput
    create: XOR<inventory_transactionsCreateWithoutOrderInput, inventory_transactionsUncheckedCreateWithoutOrderInput>
  }

  export type inventory_transactionsCreateManyOrderInputEnvelope = {
    data: inventory_transactionsCreateManyOrderInput | inventory_transactionsCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type customersUpsertWithoutOrdersInput = {
    update: XOR<customersUpdateWithoutOrdersInput, customersUncheckedUpdateWithoutOrdersInput>
    create: XOR<customersCreateWithoutOrdersInput, customersUncheckedCreateWithoutOrdersInput>
    where?: customersWhereInput
  }

  export type customersUpdateToOneWithWhereWithoutOrdersInput = {
    where?: customersWhereInput
    data: XOR<customersUpdateWithoutOrdersInput, customersUncheckedUpdateWithoutOrdersInput>
  }

  export type customersUpdateWithoutOrdersInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customersUncheckedUpdateWithoutOrdersInput = {
    customer_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_itemsUpsertWithWhereUniqueWithoutOrderInput = {
    where: order_itemsWhereUniqueInput
    update: XOR<order_itemsUpdateWithoutOrderInput, order_itemsUncheckedUpdateWithoutOrderInput>
    create: XOR<order_itemsCreateWithoutOrderInput, order_itemsUncheckedCreateWithoutOrderInput>
  }

  export type order_itemsUpdateWithWhereUniqueWithoutOrderInput = {
    where: order_itemsWhereUniqueInput
    data: XOR<order_itemsUpdateWithoutOrderInput, order_itemsUncheckedUpdateWithoutOrderInput>
  }

  export type order_itemsUpdateManyWithWhereWithoutOrderInput = {
    where: order_itemsScalarWhereInput
    data: XOR<order_itemsUpdateManyMutationInput, order_itemsUncheckedUpdateManyWithoutOrderInput>
  }

  export type order_paymentsUpsertWithWhereUniqueWithoutOrderInput = {
    where: order_paymentsWhereUniqueInput
    update: XOR<order_paymentsUpdateWithoutOrderInput, order_paymentsUncheckedUpdateWithoutOrderInput>
    create: XOR<order_paymentsCreateWithoutOrderInput, order_paymentsUncheckedCreateWithoutOrderInput>
  }

  export type order_paymentsUpdateWithWhereUniqueWithoutOrderInput = {
    where: order_paymentsWhereUniqueInput
    data: XOR<order_paymentsUpdateWithoutOrderInput, order_paymentsUncheckedUpdateWithoutOrderInput>
  }

  export type order_paymentsUpdateManyWithWhereWithoutOrderInput = {
    where: order_paymentsScalarWhereInput
    data: XOR<order_paymentsUpdateManyMutationInput, order_paymentsUncheckedUpdateManyWithoutOrderInput>
  }

  export type order_paymentsScalarWhereInput = {
    AND?: order_paymentsScalarWhereInput | order_paymentsScalarWhereInput[]
    OR?: order_paymentsScalarWhereInput[]
    NOT?: order_paymentsScalarWhereInput | order_paymentsScalarWhereInput[]
    order_payment_id?: StringFilter<"order_payments"> | string
    order_id?: IntFilter<"order_payments"> | number
    payment_method_id?: StringFilter<"order_payments"> | string
    amount?: DecimalFilter<"order_payments"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"order_payments"> | Date | string
    reference_no?: StringNullableFilter<"order_payments"> | string | null
    notes?: StringNullableFilter<"order_payments"> | string | null
  }

  export type returnsUpsertWithoutOrderInput = {
    update: XOR<returnsUpdateWithoutOrderInput, returnsUncheckedUpdateWithoutOrderInput>
    create: XOR<returnsCreateWithoutOrderInput, returnsUncheckedCreateWithoutOrderInput>
    where?: returnsWhereInput
  }

  export type returnsUpdateToOneWithWhereWithoutOrderInput = {
    where?: returnsWhereInput
    data: XOR<returnsUpdateWithoutOrderInput, returnsUncheckedUpdateWithoutOrderInput>
  }

  export type returnsUpdateWithoutOrderInput = {
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_items?: return_itemsUpdateManyWithoutReturnsNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutReturnsNestedInput
  }

  export type returnsUncheckedUpdateWithoutOrderInput = {
    return_id?: IntFieldUpdateOperationsInput | number
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_items?: return_itemsUncheckedUpdateManyWithoutReturnsNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutReturnsNestedInput
  }

  export type inventory_transactionsUpsertWithWhereUniqueWithoutOrderInput = {
    where: inventory_transactionsWhereUniqueInput
    update: XOR<inventory_transactionsUpdateWithoutOrderInput, inventory_transactionsUncheckedUpdateWithoutOrderInput>
    create: XOR<inventory_transactionsCreateWithoutOrderInput, inventory_transactionsUncheckedCreateWithoutOrderInput>
  }

  export type inventory_transactionsUpdateWithWhereUniqueWithoutOrderInput = {
    where: inventory_transactionsWhereUniqueInput
    data: XOR<inventory_transactionsUpdateWithoutOrderInput, inventory_transactionsUncheckedUpdateWithoutOrderInput>
  }

  export type inventory_transactionsUpdateManyWithWhereWithoutOrderInput = {
    where: inventory_transactionsScalarWhereInput
    data: XOR<inventory_transactionsUpdateManyMutationInput, inventory_transactionsUncheckedUpdateManyWithoutOrderInput>
  }

  export type ordersCreateWithoutOrder_itemsInput = {
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    customer?: customersCreateNestedOneWithoutOrdersInput
    order_payments?: order_paymentsCreateNestedManyWithoutOrderInput
    returns?: returnsCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutOrder_itemsInput = {
    order_id?: number
    customer_id?: string | null
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    order_payments?: order_paymentsUncheckedCreateNestedManyWithoutOrderInput
    returns?: returnsUncheckedCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutOrder_itemsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
  }

  export type productsCreateWithoutOrder_itemsInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryCreateNestedOneWithoutProductInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutProductInput
    return_items?: return_itemsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutOrder_itemsInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryUncheckedCreateNestedOneWithoutProductInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutProductInput
    return_items?: return_itemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutOrder_itemsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
  }

  export type ordersUpsertWithoutOrder_itemsInput = {
    update: XOR<ordersUpdateWithoutOrder_itemsInput, ordersUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<ordersCreateWithoutOrder_itemsInput, ordersUncheckedCreateWithoutOrder_itemsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutOrder_itemsInput, ordersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type ordersUpdateWithoutOrder_itemsInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: customersUpdateOneWithoutOrdersNestedInput
    order_payments?: order_paymentsUpdateManyWithoutOrderNestedInput
    returns?: returnsUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutOrder_itemsInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order_payments?: order_paymentsUncheckedUpdateManyWithoutOrderNestedInput
    returns?: returnsUncheckedUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type productsUpsertWithoutOrder_itemsInput = {
    update: XOR<productsUpdateWithoutOrder_itemsInput, productsUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<productsCreateWithoutOrder_itemsInput, productsUncheckedCreateWithoutOrder_itemsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutOrder_itemsInput, productsUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type productsUpdateWithoutOrder_itemsInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUpdateOneWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutOrder_itemsInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUncheckedUpdateOneWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type order_paymentsCreateWithoutPayment_methodsInput = {
    order_payment_id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
    order: ordersCreateNestedOneWithoutOrder_paymentsInput
  }

  export type order_paymentsUncheckedCreateWithoutPayment_methodsInput = {
    order_payment_id?: string
    order_id: number
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
  }

  export type order_paymentsCreateOrConnectWithoutPayment_methodsInput = {
    where: order_paymentsWhereUniqueInput
    create: XOR<order_paymentsCreateWithoutPayment_methodsInput, order_paymentsUncheckedCreateWithoutPayment_methodsInput>
  }

  export type order_paymentsCreateManyPayment_methodsInputEnvelope = {
    data: order_paymentsCreateManyPayment_methodsInput | order_paymentsCreateManyPayment_methodsInput[]
    skipDuplicates?: boolean
  }

  export type order_paymentsUpsertWithWhereUniqueWithoutPayment_methodsInput = {
    where: order_paymentsWhereUniqueInput
    update: XOR<order_paymentsUpdateWithoutPayment_methodsInput, order_paymentsUncheckedUpdateWithoutPayment_methodsInput>
    create: XOR<order_paymentsCreateWithoutPayment_methodsInput, order_paymentsUncheckedCreateWithoutPayment_methodsInput>
  }

  export type order_paymentsUpdateWithWhereUniqueWithoutPayment_methodsInput = {
    where: order_paymentsWhereUniqueInput
    data: XOR<order_paymentsUpdateWithoutPayment_methodsInput, order_paymentsUncheckedUpdateWithoutPayment_methodsInput>
  }

  export type order_paymentsUpdateManyWithWhereWithoutPayment_methodsInput = {
    where: order_paymentsScalarWhereInput
    data: XOR<order_paymentsUpdateManyMutationInput, order_paymentsUncheckedUpdateManyWithoutPayment_methodsInput>
  }

  export type ordersCreateWithoutOrder_paymentsInput = {
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    customer?: customersCreateNestedOneWithoutOrdersInput
    order_items?: order_itemsCreateNestedManyWithoutOrderInput
    returns?: returnsCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutOrder_paymentsInput = {
    order_id?: number
    customer_id?: string | null
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrderInput
    returns?: returnsUncheckedCreateNestedOneWithoutOrderInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutOrder_paymentsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutOrder_paymentsInput, ordersUncheckedCreateWithoutOrder_paymentsInput>
  }

  export type payment_methodsCreateWithoutOrder_paymentsInput = {
    payment_method_id?: string
    method_name: string
    description?: string | null
    created_at?: Date | string
  }

  export type payment_methodsUncheckedCreateWithoutOrder_paymentsInput = {
    payment_method_id?: string
    method_name: string
    description?: string | null
    created_at?: Date | string
  }

  export type payment_methodsCreateOrConnectWithoutOrder_paymentsInput = {
    where: payment_methodsWhereUniqueInput
    create: XOR<payment_methodsCreateWithoutOrder_paymentsInput, payment_methodsUncheckedCreateWithoutOrder_paymentsInput>
  }

  export type ordersUpsertWithoutOrder_paymentsInput = {
    update: XOR<ordersUpdateWithoutOrder_paymentsInput, ordersUncheckedUpdateWithoutOrder_paymentsInput>
    create: XOR<ordersCreateWithoutOrder_paymentsInput, ordersUncheckedCreateWithoutOrder_paymentsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutOrder_paymentsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutOrder_paymentsInput, ordersUncheckedUpdateWithoutOrder_paymentsInput>
  }

  export type ordersUpdateWithoutOrder_paymentsInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: customersUpdateOneWithoutOrdersNestedInput
    order_items?: order_itemsUpdateManyWithoutOrderNestedInput
    returns?: returnsUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutOrder_paymentsInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrderNestedInput
    returns?: returnsUncheckedUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type payment_methodsUpsertWithoutOrder_paymentsInput = {
    update: XOR<payment_methodsUpdateWithoutOrder_paymentsInput, payment_methodsUncheckedUpdateWithoutOrder_paymentsInput>
    create: XOR<payment_methodsCreateWithoutOrder_paymentsInput, payment_methodsUncheckedCreateWithoutOrder_paymentsInput>
    where?: payment_methodsWhereInput
  }

  export type payment_methodsUpdateToOneWithWhereWithoutOrder_paymentsInput = {
    where?: payment_methodsWhereInput
    data: XOR<payment_methodsUpdateWithoutOrder_paymentsInput, payment_methodsUncheckedUpdateWithoutOrder_paymentsInput>
  }

  export type payment_methodsUpdateWithoutOrder_paymentsInput = {
    payment_method_id?: StringFieldUpdateOperationsInput | string
    method_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payment_methodsUncheckedUpdateWithoutOrder_paymentsInput = {
    payment_method_id?: StringFieldUpdateOperationsInput | string
    method_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ordersCreateWithoutReturnsInput = {
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    customer?: customersCreateNestedOneWithoutOrdersInput
    order_items?: order_itemsCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsCreateNestedManyWithoutOrderInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutReturnsInput = {
    order_id?: number
    customer_id?: string | null
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsUncheckedCreateNestedManyWithoutOrderInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutReturnsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutReturnsInput, ordersUncheckedCreateWithoutReturnsInput>
  }

  export type return_itemsCreateWithoutReturnsInput = {
    return_item_id?: string
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
    product: productsCreateNestedOneWithoutReturn_itemsInput
  }

  export type return_itemsUncheckedCreateWithoutReturnsInput = {
    return_item_id?: string
    product_id: string
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
  }

  export type return_itemsCreateOrConnectWithoutReturnsInput = {
    where: return_itemsWhereUniqueInput
    create: XOR<return_itemsCreateWithoutReturnsInput, return_itemsUncheckedCreateWithoutReturnsInput>
  }

  export type return_itemsCreateManyReturnsInputEnvelope = {
    data: return_itemsCreateManyReturnsInput | return_itemsCreateManyReturnsInput[]
    skipDuplicates?: boolean
  }

  export type inventory_transactionsCreateWithoutReturnsInput = {
    transaction_id?: string
    change_type: string
    quantity_change: number
    created_at?: Date | string
    product: productsCreateNestedOneWithoutInventory_transactionsInput
    order?: ordersCreateNestedOneWithoutInventory_transactionsInput
  }

  export type inventory_transactionsUncheckedCreateWithoutReturnsInput = {
    transaction_id?: string
    product_id: string
    change_type: string
    quantity_change: number
    related_order_id?: number | null
    created_at?: Date | string
  }

  export type inventory_transactionsCreateOrConnectWithoutReturnsInput = {
    where: inventory_transactionsWhereUniqueInput
    create: XOR<inventory_transactionsCreateWithoutReturnsInput, inventory_transactionsUncheckedCreateWithoutReturnsInput>
  }

  export type inventory_transactionsCreateManyReturnsInputEnvelope = {
    data: inventory_transactionsCreateManyReturnsInput | inventory_transactionsCreateManyReturnsInput[]
    skipDuplicates?: boolean
  }

  export type ordersUpsertWithoutReturnsInput = {
    update: XOR<ordersUpdateWithoutReturnsInput, ordersUncheckedUpdateWithoutReturnsInput>
    create: XOR<ordersCreateWithoutReturnsInput, ordersUncheckedCreateWithoutReturnsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutReturnsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutReturnsInput, ordersUncheckedUpdateWithoutReturnsInput>
  }

  export type ordersUpdateWithoutReturnsInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: customersUpdateOneWithoutOrdersNestedInput
    order_items?: order_itemsUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUpdateManyWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutReturnsInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUncheckedUpdateManyWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type return_itemsUpsertWithWhereUniqueWithoutReturnsInput = {
    where: return_itemsWhereUniqueInput
    update: XOR<return_itemsUpdateWithoutReturnsInput, return_itemsUncheckedUpdateWithoutReturnsInput>
    create: XOR<return_itemsCreateWithoutReturnsInput, return_itemsUncheckedCreateWithoutReturnsInput>
  }

  export type return_itemsUpdateWithWhereUniqueWithoutReturnsInput = {
    where: return_itemsWhereUniqueInput
    data: XOR<return_itemsUpdateWithoutReturnsInput, return_itemsUncheckedUpdateWithoutReturnsInput>
  }

  export type return_itemsUpdateManyWithWhereWithoutReturnsInput = {
    where: return_itemsScalarWhereInput
    data: XOR<return_itemsUpdateManyMutationInput, return_itemsUncheckedUpdateManyWithoutReturnsInput>
  }

  export type inventory_transactionsUpsertWithWhereUniqueWithoutReturnsInput = {
    where: inventory_transactionsWhereUniqueInput
    update: XOR<inventory_transactionsUpdateWithoutReturnsInput, inventory_transactionsUncheckedUpdateWithoutReturnsInput>
    create: XOR<inventory_transactionsCreateWithoutReturnsInput, inventory_transactionsUncheckedCreateWithoutReturnsInput>
  }

  export type inventory_transactionsUpdateWithWhereUniqueWithoutReturnsInput = {
    where: inventory_transactionsWhereUniqueInput
    data: XOR<inventory_transactionsUpdateWithoutReturnsInput, inventory_transactionsUncheckedUpdateWithoutReturnsInput>
  }

  export type inventory_transactionsUpdateManyWithWhereWithoutReturnsInput = {
    where: inventory_transactionsScalarWhereInput
    data: XOR<inventory_transactionsUpdateManyMutationInput, inventory_transactionsUncheckedUpdateManyWithoutReturnsInput>
  }

  export type returnsCreateWithoutReturn_itemsInput = {
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    order?: ordersCreateNestedOneWithoutReturnsInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutReturnsInput
  }

  export type returnsUncheckedCreateWithoutReturn_itemsInput = {
    return_id?: number
    order_id?: number | null
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutReturnsInput
  }

  export type returnsCreateOrConnectWithoutReturn_itemsInput = {
    where: returnsWhereUniqueInput
    create: XOR<returnsCreateWithoutReturn_itemsInput, returnsUncheckedCreateWithoutReturn_itemsInput>
  }

  export type productsCreateWithoutReturn_itemsInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryCreateNestedOneWithoutProductInput
    order_items?: order_itemsCreateNestedManyWithoutProductInput
    inventory_transactions?: inventory_transactionsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutReturn_itemsInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryUncheckedCreateNestedOneWithoutProductInput
    order_items?: order_itemsUncheckedCreateNestedManyWithoutProductInput
    inventory_transactions?: inventory_transactionsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutReturn_itemsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutReturn_itemsInput, productsUncheckedCreateWithoutReturn_itemsInput>
  }

  export type returnsUpsertWithoutReturn_itemsInput = {
    update: XOR<returnsUpdateWithoutReturn_itemsInput, returnsUncheckedUpdateWithoutReturn_itemsInput>
    create: XOR<returnsCreateWithoutReturn_itemsInput, returnsUncheckedCreateWithoutReturn_itemsInput>
    where?: returnsWhereInput
  }

  export type returnsUpdateToOneWithWhereWithoutReturn_itemsInput = {
    where?: returnsWhereInput
    data: XOR<returnsUpdateWithoutReturn_itemsInput, returnsUncheckedUpdateWithoutReturn_itemsInput>
  }

  export type returnsUpdateWithoutReturn_itemsInput = {
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: ordersUpdateOneWithoutReturnsNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutReturnsNestedInput
  }

  export type returnsUncheckedUpdateWithoutReturn_itemsInput = {
    return_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutReturnsNestedInput
  }

  export type productsUpsertWithoutReturn_itemsInput = {
    update: XOR<productsUpdateWithoutReturn_itemsInput, productsUncheckedUpdateWithoutReturn_itemsInput>
    create: XOR<productsCreateWithoutReturn_itemsInput, productsUncheckedCreateWithoutReturn_itemsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutReturn_itemsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutReturn_itemsInput, productsUncheckedUpdateWithoutReturn_itemsInput>
  }

  export type productsUpdateWithoutReturn_itemsInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUpdateOneWithoutProductNestedInput
    order_items?: order_itemsUpdateManyWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutReturn_itemsInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUncheckedUpdateOneWithoutProductNestedInput
    order_items?: order_itemsUncheckedUpdateManyWithoutProductNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productsCreateWithoutInventory_transactionsInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryCreateNestedOneWithoutProductInput
    order_items?: order_itemsCreateNestedManyWithoutProductInput
    return_items?: return_itemsCreateNestedManyWithoutProductInput
  }

  export type productsUncheckedCreateWithoutInventory_transactionsInput = {
    product_id?: string
    name: string
    sku: string
    barcode?: string | null
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    created_at?: Date | string
    inventory?: inventoryUncheckedCreateNestedOneWithoutProductInput
    order_items?: order_itemsUncheckedCreateNestedManyWithoutProductInput
    return_items?: return_itemsUncheckedCreateNestedManyWithoutProductInput
  }

  export type productsCreateOrConnectWithoutInventory_transactionsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutInventory_transactionsInput, productsUncheckedCreateWithoutInventory_transactionsInput>
  }

  export type ordersCreateWithoutInventory_transactionsInput = {
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    customer?: customersCreateNestedOneWithoutOrdersInput
    order_items?: order_itemsCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsCreateNestedManyWithoutOrderInput
    returns?: returnsCreateNestedOneWithoutOrderInput
  }

  export type ordersUncheckedCreateWithoutInventory_transactionsInput = {
    order_id?: number
    customer_id?: string | null
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedCreateNestedManyWithoutOrderInput
    order_payments?: order_paymentsUncheckedCreateNestedManyWithoutOrderInput
    returns?: returnsUncheckedCreateNestedOneWithoutOrderInput
  }

  export type ordersCreateOrConnectWithoutInventory_transactionsInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutInventory_transactionsInput, ordersUncheckedCreateWithoutInventory_transactionsInput>
  }

  export type returnsCreateWithoutInventory_transactionsInput = {
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    order?: ordersCreateNestedOneWithoutReturnsInput
    return_items?: return_itemsCreateNestedManyWithoutReturnsInput
  }

  export type returnsUncheckedCreateWithoutInventory_transactionsInput = {
    return_id?: number
    order_id?: number | null
    return_date?: Date | string
    status?: string
    refund_amount?: Decimal | DecimalJsLike | number | string
    return_items?: return_itemsUncheckedCreateNestedManyWithoutReturnsInput
  }

  export type returnsCreateOrConnectWithoutInventory_transactionsInput = {
    where: returnsWhereUniqueInput
    create: XOR<returnsCreateWithoutInventory_transactionsInput, returnsUncheckedCreateWithoutInventory_transactionsInput>
  }

  export type productsUpsertWithoutInventory_transactionsInput = {
    update: XOR<productsUpdateWithoutInventory_transactionsInput, productsUncheckedUpdateWithoutInventory_transactionsInput>
    create: XOR<productsCreateWithoutInventory_transactionsInput, productsUncheckedCreateWithoutInventory_transactionsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutInventory_transactionsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutInventory_transactionsInput, productsUncheckedUpdateWithoutInventory_transactionsInput>
  }

  export type productsUpdateWithoutInventory_transactionsInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUpdateOneWithoutProductNestedInput
    order_items?: order_itemsUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUpdateManyWithoutProductNestedInput
  }

  export type productsUncheckedUpdateWithoutInventory_transactionsInput = {
    product_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inventory?: inventoryUncheckedUpdateOneWithoutProductNestedInput
    order_items?: order_itemsUncheckedUpdateManyWithoutProductNestedInput
    return_items?: return_itemsUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ordersUpsertWithoutInventory_transactionsInput = {
    update: XOR<ordersUpdateWithoutInventory_transactionsInput, ordersUncheckedUpdateWithoutInventory_transactionsInput>
    create: XOR<ordersCreateWithoutInventory_transactionsInput, ordersUncheckedCreateWithoutInventory_transactionsInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutInventory_transactionsInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutInventory_transactionsInput, ordersUncheckedUpdateWithoutInventory_transactionsInput>
  }

  export type ordersUpdateWithoutInventory_transactionsInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    customer?: customersUpdateOneWithoutOrdersNestedInput
    order_items?: order_itemsUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUpdateManyWithoutOrderNestedInput
    returns?: returnsUpdateOneWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutInventory_transactionsInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUncheckedUpdateManyWithoutOrderNestedInput
    returns?: returnsUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type returnsUpsertWithoutInventory_transactionsInput = {
    update: XOR<returnsUpdateWithoutInventory_transactionsInput, returnsUncheckedUpdateWithoutInventory_transactionsInput>
    create: XOR<returnsCreateWithoutInventory_transactionsInput, returnsUncheckedCreateWithoutInventory_transactionsInput>
    where?: returnsWhereInput
  }

  export type returnsUpdateToOneWithWhereWithoutInventory_transactionsInput = {
    where?: returnsWhereInput
    data: XOR<returnsUpdateWithoutInventory_transactionsInput, returnsUncheckedUpdateWithoutInventory_transactionsInput>
  }

  export type returnsUpdateWithoutInventory_transactionsInput = {
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: ordersUpdateOneWithoutReturnsNestedInput
    return_items?: return_itemsUpdateManyWithoutReturnsNestedInput
  }

  export type returnsUncheckedUpdateWithoutInventory_transactionsInput = {
    return_id?: IntFieldUpdateOperationsInput | number
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    return_items?: return_itemsUncheckedUpdateManyWithoutReturnsNestedInput
  }

  export type ordersCreateManyCustomerInput = {
    order_id?: number
    order_date?: Date | string
    status?: string
    total_amount?: Decimal | DecimalJsLike | number | string
  }

  export type ordersUpdateWithoutCustomerInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUpdateManyWithoutOrderNestedInput
    returns?: returnsUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUpdateManyWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateWithoutCustomerInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order_items?: order_itemsUncheckedUpdateManyWithoutOrderNestedInput
    order_payments?: order_paymentsUncheckedUpdateManyWithoutOrderNestedInput
    returns?: returnsUncheckedUpdateOneWithoutOrderNestedInput
    inventory_transactions?: inventory_transactionsUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutCustomerInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsCreateManyProductInput = {
    order_item_id?: string
    order_id: number
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type inventory_transactionsCreateManyProductInput = {
    transaction_id?: string
    change_type: string
    quantity_change: number
    related_order_id?: number | null
    related_return_id?: number | null
    created_at?: Date | string
  }

  export type return_itemsCreateManyProductInput = {
    return_item_id?: string
    return_id: number
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
  }

  export type order_itemsUpdateWithoutProductInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    order?: ordersUpdateOneRequiredWithoutOrder_itemsNestedInput
  }

  export type order_itemsUncheckedUpdateWithoutProductInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsUncheckedUpdateManyWithoutProductInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type inventory_transactionsUpdateWithoutProductInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: ordersUpdateOneWithoutInventory_transactionsNestedInput
    returns?: returnsUpdateOneWithoutInventory_transactionsNestedInput
  }

  export type inventory_transactionsUncheckedUpdateWithoutProductInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    related_return_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_transactionsUncheckedUpdateManyWithoutProductInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    related_return_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type return_itemsUpdateWithoutProductInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    returns?: returnsUpdateOneRequiredWithoutReturn_itemsNestedInput
  }

  export type return_itemsUncheckedUpdateWithoutProductInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    return_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type return_itemsUncheckedUpdateManyWithoutProductInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    return_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsCreateManyOrderInput = {
    order_item_id?: string
    product_id: string
    quantity: number
    unit_price: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
  }

  export type order_paymentsCreateManyOrderInput = {
    order_payment_id?: string
    payment_method_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
  }

  export type inventory_transactionsCreateManyOrderInput = {
    transaction_id?: string
    product_id: string
    change_type: string
    quantity_change: number
    related_return_id?: number | null
    created_at?: Date | string
  }

  export type order_itemsUpdateWithoutOrderInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: productsUpdateOneRequiredWithoutOrder_itemsNestedInput
  }

  export type order_itemsUncheckedUpdateWithoutOrderInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_itemsUncheckedUpdateManyWithoutOrderInput = {
    order_item_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type order_paymentsUpdateWithoutOrderInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_methods?: payment_methodsUpdateOneRequiredWithoutOrder_paymentsNestedInput
  }

  export type order_paymentsUncheckedUpdateWithoutOrderInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_paymentsUncheckedUpdateManyWithoutOrderInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    payment_method_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inventory_transactionsUpdateWithoutOrderInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneRequiredWithoutInventory_transactionsNestedInput
    returns?: returnsUpdateOneWithoutInventory_transactionsNestedInput
  }

  export type inventory_transactionsUncheckedUpdateWithoutOrderInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_return_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_transactionsUncheckedUpdateManyWithoutOrderInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_return_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type order_paymentsCreateManyPayment_methodsInput = {
    order_payment_id?: string
    order_id: number
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    reference_no?: string | null
    notes?: string | null
  }

  export type order_paymentsUpdateWithoutPayment_methodsInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    order?: ordersUpdateOneRequiredWithoutOrder_paymentsNestedInput
  }

  export type order_paymentsUncheckedUpdateWithoutPayment_methodsInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type order_paymentsUncheckedUpdateManyWithoutPayment_methodsInput = {
    order_payment_id?: StringFieldUpdateOperationsInput | string
    order_id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type return_itemsCreateManyReturnsInput = {
    return_item_id?: string
    product_id: string
    quantity: number
    refund_amount: Decimal | DecimalJsLike | number | string
  }

  export type inventory_transactionsCreateManyReturnsInput = {
    transaction_id?: string
    product_id: string
    change_type: string
    quantity_change: number
    related_order_id?: number | null
    created_at?: Date | string
  }

  export type return_itemsUpdateWithoutReturnsInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    product?: productsUpdateOneRequiredWithoutReturn_itemsNestedInput
  }

  export type return_itemsUncheckedUpdateWithoutReturnsInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type return_itemsUncheckedUpdateManyWithoutReturnsInput = {
    return_item_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    refund_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type inventory_transactionsUpdateWithoutReturnsInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: productsUpdateOneRequiredWithoutInventory_transactionsNestedInput
    order?: ordersUpdateOneWithoutInventory_transactionsNestedInput
  }

  export type inventory_transactionsUncheckedUpdateWithoutReturnsInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inventory_transactionsUncheckedUpdateManyWithoutReturnsInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    product_id?: StringFieldUpdateOperationsInput | string
    change_type?: StringFieldUpdateOperationsInput | string
    quantity_change?: IntFieldUpdateOperationsInput | number
    related_order_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CustomersCountOutputTypeDefaultArgs instead
     */
    export type CustomersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductsCountOutputTypeDefaultArgs instead
     */
    export type ProductsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdersCountOutputTypeDefaultArgs instead
     */
    export type OrdersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Payment_methodsCountOutputTypeDefaultArgs instead
     */
    export type Payment_methodsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Payment_methodsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReturnsCountOutputTypeDefaultArgs instead
     */
    export type ReturnsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReturnsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use customersDefaultArgs instead
     */
    export type customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = customersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productsDefaultArgs instead
     */
    export type productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inventoryDefaultArgs instead
     */
    export type inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = inventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ordersDefaultArgs instead
     */
    export type ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ordersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_itemsDefaultArgs instead
     */
    export type order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use payment_methodsDefaultArgs instead
     */
    export type payment_methodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = payment_methodsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_paymentsDefaultArgs instead
     */
    export type order_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_paymentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use returnsDefaultArgs instead
     */
    export type returnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = returnsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use return_itemsDefaultArgs instead
     */
    export type return_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = return_itemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use inventory_transactionsDefaultArgs instead
     */
    export type inventory_transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = inventory_transactionsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}